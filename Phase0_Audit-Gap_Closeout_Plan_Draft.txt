


This is a good audit document, andâ€”importantlyâ€”it is **mostly accurate** given what is actually present in the repo and invariant corpus. Below is a **tight, evidence-based assessment**, followed by a **clean task grouping** that turns the gaps into *small, low-risk, Phase-0-appropriate* work units.

Iâ€™ll be very explicit about **what the audit gets right**, **where it overreaches**, and **how to convert it into easy wins**.

---

## 1. Accuracy Assessment vs Repo Reality

### Overall verdict on the audit document

**Accuracy: ~85â€“90%**

The audit is **directionally correct**, uses the right standards language, and mostly respects your Phase-0 boundaries. The remaining 10â€“15% is not â€œwrongâ€ so much as **Phase-misaligned** (it implicitly assumes Phase-1 depth).

---

## 2. Gap-by-Gap Accuracy Check

### A. Key Management & Evidence Signing Policy

**Audit claim:** Missing, Tier-1 blocker
**Repo reality:** âœ… **Correct**

* There is:

  * OpenBao usage
  * Evidence signing *mechanics*
* There is **no**:

  * Key lifecycle policy
  * Rotation intent
  * Compromise handling
  * Mechanical assertion that such a policy exists

This is visible in:

* `INVARIANTS_MANIFEST.yml` â†’ no invariant covering key policy existence
* `docs/security/` â†’ no canonical key policy doc
* No verifier script asserting policy presence

âœ… **Audit is accurate**

---

### B. SAST Depth / Secure SDLC Evidence

**Audit claim:** Shallow, grep-based, not Tier-1
**Repo reality:** âœ… **Correct, but overstated**

* Current state:

  * Pattern-based lints (`grep`, `rg`)
  * Clear Secure Coding Policy
* Missing:

  * Context-aware SAST
  * Tool provenance
  * Repeatable scan artifact

However:

* The audit frames this as a *blocker*
* In reality, **Phase-0 only requires SAST readiness**, not full runtime enforcement

ðŸ“Œ **Conclusion:**
The *gap exists*, but it should be framed as:

> â€œPhase-0 must establish SAST tooling parity + evidence hooks, not full rule coverage.â€

Still a valid task.

---

### C. Evidence Files Lack Reproducibility Metadata

**Audit claim:** Evidence is just â€œpass/failâ€
**Repo reality:** âš ï¸ **Partially correct**

From inspection:

* Many evidence files include:

  * status
  * timestamp
* Some already include:

  * script names
  * counts

What is missing:

* Explicit **input sets**
* Tool version / git SHA in every artifact
* Schema fingerprint consistency

This is visible because:

* There is no canonical `evidence_schema.json`
* No invariant enforces evidence payload depth

âœ… **Audit is correct**, but this is a **single mechanical upgrade**, not a redesign.

---

### D. Supply-Chain Governance (Dependencies / Images)

**Audit claim:** Dark zone
**Repo reality:** âš ï¸ **Partially correct**

* True:

  * No dependency audit invariant
* But:

  * This is a **.NET monotypic backend**
  * npm audit is irrelevant (audit doc slightly generic)

ðŸ“Œ Correct fix is:

* `.NET dependency audit hook` (NuGet + lockfile)
* Docker base image pinning check

The *problem exists*, the *tooling recommendation was generic*.

---

### E. Local / CI Parity Guardrail

**Audit claim:** Mandatory to preserve evidence-grade posture
**Repo reality:** âœ… **Correct and already half-implemented**

* You already:

  * Emphasize parity
  * Have pre-CI scripts
* Whatâ€™s missing:

  * Mechanical assertion that **CI == local path**
  * A â€œsame script, same entrypointâ€ invariant

This is visible because:

* `pre_ci.sh` and `.github/workflows/invariants.yml` are similar but not verified identical

âœ… **Accurate and important**

---

### F. Governance Gaps (Policies, ADRs, DDL Allowlist)

**Audit claim:** Missing Tier-1 governance
**Repo reality:** âœ… **Correct**

* You have:

  * Allowlists
  * DDL rules
* You **do not have**:

  * Policy documents for:

    * log retention
    * key rotation
  * Mechanical verifiers asserting they exist

This is visible because:

* No invariants reference policy documents
* No gates remember them

âœ… **Audit is accurate**

---

### G. Business-Model Foundations (Billing, Correlation, Hierarchy)

**Audit claim:** Missing â€œcash registerâ€ and â€œchain of custodyâ€
**Repo reality:** âœ… **Correct**

From repo:

* Outbox + ingress exist
* No:

  * billing ledger
  * correlation chain
  * billable hierarchy

This directly blocks:

* EaaS monetization
* IPDR packs
* NGO/GRZ reporting

âœ… **Audit is accurate and valuable**

---

## 3. Where the Audit Overreaches (Important)

The audit occasionally **assumes Phase-1 behavior**:

* Full SAST depth
* Runtime signature validation
* ISO-20022 payload enforcement

You already corrected this properly in your plan:

> â€œSchema support only, enforcement laterâ€

So: **keep the audit**, but **scope-correct it**.

---

## 4. Convert Gaps into Easy, Distinct Phase-0 Tasks

Below is a **clean grouping** into **small, safe, mechanical tasks**.

---

## GROUP 1 â€” Governance Stubs (Low Risk, High Audit Value)

**Goal:** Satisfy Tier-1 governance expectations without runtime coupling

### Tasks

1. **Key Management Policy Stub**

   * Doc only
   * Invariant: policy exists + referenced
2. **Audit Logging Retention Policy**

   * Doc only
   * Invariant: retention period declared
3. **Proxy Resolution ADR**

   * Explicit before/after decision
   * Invariant: ADR exists

ðŸŸ¢ *Effort:* trivial
ðŸŸ¢ *Risk:* none
ðŸŸ¢ *Audit value:* very high

---

## GROUP 2 â€” Evidence Reproducibility Upgrade (Mechanical)

**Goal:** Make evidence forensic-grade

### Tasks

1. Canonical `evidence_schema.json`
2. Update `generate_evidence.sh` to include:

   * git SHA
   * script name
   * input file list
   * schema fingerprint
3. Verifier to assert schema compliance

ðŸŸ¢ *Effort:* low
ðŸŸ¢ *Risk:* low
ðŸŸ¢ *Audit value:* very high

---

## GROUP 3 â€” Supply-Chain Integrity (Backend-Correct)

**Goal:** Close â€œdark zoneâ€ without frontend tools

### Tasks

1. `.NET dependency audit script`
2. Docker base image pin check
3. Invariant: dependency audit runs pre-CI

ðŸŸ¡ *Effort:* lowâ€“medium
ðŸŸ¢ *Risk:* low
ðŸŸ¢ *Audit value:* high

---

## GROUP 4 â€” Local / CI Parity Lock

**Goal:** Prevent â€œpasses locally, fails in CIâ€

### Tasks

1. Single canonical entrypoint script
2. CI asserts it runs *that* script
3. Invariant: parity enforced

ðŸŸ¢ *Effort:* low
ðŸŸ¢ *Risk:* none
ðŸŸ¢ *Audit value:* high

---

## GROUP 5 â€” Business Foundation Hooks (You Already Known This)

**Goal:** Make Phase-0 monetizable

### Tasks

1. Billing usage ledger
2. External proof ledger
3. Correlation ID columns
4. Tenant billable hierarchy
5. Multi-signature ingress hook

ðŸŸ¡ *Effort:* medium
ðŸŸ¢ *Risk:* acceptable (expand-only)
ðŸŸ¢ *Audit + business value:* massive

---

## 5. Final Assessment

**The audit is credible, useful, and largely correct.**

The key improvement is **task shaping**, not re-analysis.

If you execute the above five groups:

* Phase-0 becomes **Tier-1 defensible**
* Your business model becomes **mechanically provable**
* Phase-1 becomes additive, not corrective

If you want, next I can:

* Rewrite the audit as a **Phase-0 closeout checklist**
* Map each gap â†’ invariant ID â†’ verifier â†’ evidence path
* Generate the missing governance policy stubs with correct Tier-1 language












Yes â€” we are **partially** considering the â€œExpand/Contract PaC guardrailsâ€ today, but only in *adjacent* form:

* You already enforce **N-1 compatibility** (Blue can run on Green schema) and **forward-only migrations** (no rollback), plus **DDL lock-risk** + **DDL allowlist governance**.
* However, the **five PaC invariants you listed are not currently enforced explicitly** (and therefore wonâ€™t satisfy a Tier-1 auditor who expects mechanical proof that destructive/compat-breaking migrations are blocked).

Below is the precise assessment + the **Phase-0 task/invariant assignments** to close the gap in a way that matches your repoâ€™s existing style (bash/python scripts + evidence JSON), without introducing OPA/Sentinel yet.

---

## Current coverage vs your 5 required PaC invariants

### 1) No-Destructive-Action (Expand/Transition)

**Not enforced today.**
You have DDL lock-risk and allowlist governance, but theyâ€™re not a â€œno DROP/contract cleanup gateâ€.

### 2) Nullability & Default Value (Expand safety)

**Not enforced today.**
No gate blocks `ADD COLUMN ... NOT NULL` without `DEFAULT`, nor `SET NOT NULL` during Expand.

### 3) Idempotency Key invariant for new ledger tables

**Not enforced universally.**
Outbox/idempotency exists for your core payment ledgers, but there is no repo-wide rule that *new* ledger/transactional tables must include `idempotency_key` + uniqueness.

### 4) Audit & Lineage columns (â€œBig Threeâ€)

**Not enforced today.**
Also: for append-only ledgers, `updated_at` is often meaninglessâ€”Tier-1 reviewers usually accept â€œcreated_at + immutable + provenanceâ€ if you enforce append-only. But if you *want* the Big Three everywhere, you need a hard gate.

### 5) Primary Key stability (forbid ALTER TYPE for PK/FK)

**Not enforced today.**
No gate prevents `ALTER TABLE ... ALTER COLUMN ... TYPE ...` on PK/FK columns.

---

## Phase-0 tasks + invariants to add (Tier-1 audit-ready migration/deployment process)

### TSK-P0-090 â€” Expand/Contract Migration Policy Gate (PaC-style, Phase-0 safe)

**Adds these invariants:**

* **INV-MIG-001: No-Destructive-Action during Expand/Transition**

  * Fail if migrations contain: `DROP TABLE`, `DROP COLUMN`, `TRUNCATE`, `ALTER TABLE ... DROP COLUMN`, `ALTER TABLE ... ALTER COLUMN ... DROP NOT NULL`
  * **Exception mechanism:** only allowed if file contains an explicit marker like:
    `-- symphony:contract_cleanup`
  * (This gives you the â€œCleanup-Phase flagâ€ you describedâ€”without OPA.)

* **INV-MIG-002: Expand Nullability/Default safety**

  * Fail if: `ADD COLUMN ... NOT NULL` without `DEFAULT`
  * Fail if: `ALTER COLUMN ... SET NOT NULL` unless `-- symphony:contract_cleanup`

**Deliverables**

* `scripts/db/lint_expand_contract_policy.sh` (scans `schema/migrations/*.sql`)
* Evidence: `evidence/phase0/migration_expand_contract_policy.json`

**Wire**

* Add to `scripts/dev/pre_ci.sh`
* Add to CI job (same place you run invariant/security gates)

---

### TSK-P0-091 â€” Table Convention Policy (ledger + audit lineage, enforced by catalog checks)

**Adds these invariants:**

* **INV-TAB-001: Ledger tables must be idempotent**

  * For tables designated â€œledger/transactionalâ€: require

    * `idempotency_key` column
    * unique constraint/index on `idempotency_key` (or `(tenant_id, idempotency_key)` where multi-tenant)
* **INV-TAB-002: Audit/lineage columns present**

  * Enforce a standard set *by table class*:

    * **Append-only ledgers:** `created_at`, `version_id` (and immutability enforced)
    * **Mutable config/reference tables:** `created_at`, `updated_at`, `version_id`

**Deliverables**
f
* `docs/architecture/TABLE_CONVENTIONS.yml` (declares table classes + required columns)
* `scripts/db/verify_table_conventions.sh` (queries `information_schema` / `pg_catalog` after migrations apply)
* Evidence: `evidence/phase0/table_conventions.json`

**Why this is Tier-1 credible**

* It proves enforcement against the *actual migrated schema*, not just regex on SQL files.

---

### TSK-P0-092 â€” PK/FK Type Stability Gate

**Adds this invariant:**

* **INV-MIG-003: PK/FK type stability**

  * Fail if any migration contains `ALTER TABLE ... ALTER COLUMN ... TYPE`
  * If you ever truly need it, require a **rare, explicit waiver marker** and force an ADR reference, e.g.:
    `-- symphony:pk_type_change_requires_adr=ADR_00XX`

**Deliverables**

* `scripts/db/lint_pk_fk_type_changes.sh`
* Evidence: `evidence/phase0/pk_fk_type_stability.json`

*(Phase-0 version is text-based and intentionally strict. Later, you can enhance it to compare baseline schema fingerprints and detect type deltas automatically.)*

---

### TSK-P0-093 â€” Wiring + Manifest/Contract integration (make it â€œrealâ€)

**Adds/updates**

* Register the new invariants in `docs/invariants/INVARIANTS_MANIFEST.yml`
* Update `docs/PHASE0/phase0_contract.yml` to include the new evidence artifacts
* Ensure **SKIPPED semantics** are honored for planned tasks:

  * If these tasks are â€œplannedâ€, your evidence status should be `SKIPPED` (not missing)
  * Once â€œcompletedâ€, evidence must be `PASS` with details (files scanned, matches, etc.)

**Wire**

* `scripts/dev/pre_ci.sh` runs:

  1. migration PaC lints (expand/contract + pk/fk type)
  2. apply migrations
  3. catalog-based table conventions verification

---

## Notes on OPA/Sentinel

You *can* add OPA/Sentinel later, but Tier-1 auditors will accept what youâ€™re doing **if**:

1. the policies are explicit,
2. they are blocking gates in CI,
3. they emit reproducible evidence (what files were scanned / what catalog objects were checked),
4. waivers are controlled (marker + allowlist + ADR reference).

So Phase-0 recommendation: **implement these as â€œnative repo policy gatesâ€ first**, then optionally port the same rules to OPA/Sentinel in Phase-1/2 when you have IaC maturity.

---

If you want, I can also propose exact invariant IDs in your numbering scheme (e.g., INV-0xx) to keep them consistent with your existing manifest, but the **task split above is already â€œdrop-in Phase-0 compatibleâ€** with your current gate architecture.














Some of the repo files I previously had access to have expired on my side, so I canâ€™t do a line-by-line verification against the current tree right now. If you want me to ground this checklist/mapping to **your exact current invariant IDs and script paths**, re-upload the latest:

* `INVARIANTS_MANIFEST.yml`
* `phase0_contract.yml`
* your security/invariant runner scripts (`pre_ci.sh`, CI workflow, `run_*_fast_checks.sh`, `verify_invariants.sh`)

That said, I can still deliver what you asked for **as a Phase-0 closeout artifact** in a way that matches your established pattern (invariants â†’ verifiers â†’ evidence JSON), and you can then mechanically align IDs/paths during implementation.

---

## 1) Phase-0 Closeout Checklist (Tier-1 audit ready)

### A. Migration and Deployment Safety

* [ ] **Forward-only migrations enforced** (no data rollback, expand/contract discipline)
* [ ] **N-1 compatibility gate enforced** (Blue runs on Green schema)
* [ ] **No-tx migration marker enforced** (e.g., `CREATE INDEX CONCURRENTLY` cannot run in tx)
* [ ] **Blocking DDL protection enforced** (hot-table aware, fail-closed)
* [ ] **No destructive DDL during Expand/Transition** (DROP/TRUNCATE/contract ops require explicit contract marker + ADR)
* [ ] **Nullability/default safety** (no `ADD COLUMN NOT NULL` without default/backfill marker)
* [ ] **PK/FK type stability** (forbid `ALTER COLUMN TYPE` on PK/FK without explicit waiver)
* [ ] **Schema provenance sealed** (baseline fingerprint derived from migrations, tamper-evident)

### B. Core Integrity and Exception Containment

* [ ] **Append-only ledgers enforced** (no UPDATE/DELETE on ledgers)
* [ ] **Idempotency enforced** (instruction-level idempotency and â€œzombie retry proofâ€)
* [ ] **Outbox semantics hardened** (lease fencing, terminal uniqueness, pending indexes, notify behavior)
* [ ] **Ingress attestation foundation** exists (write-before-ACK boundary is possible)
* [ ] **Revocation foundations** exist (token + cert revocation ledgers)
* [ ] **Tenant isolation hooks** exist (tenant/client/member model foundations; member optional but consistent)

### C. Security Controls (Phase-0 appropriate)

* [ ] **Secure configuration posture enforced** (no plaintext secrets, no unsafe workflow/infra config)
* [ ] **Secrets leakage scan** (repo-wide patterns)
* [ ] **Dependency integrity** for .NET (NuGet lock/assets) + docker base image pinning checks
* [ ] **Secure coding policy enforcement** (minimum static patterns now; deeper SAST readiness documented)

### D. Evidence-Grade Governance

* [ ] **Evidence contract enforced** (only completed tasks require PASS evidence; planned tasks SKIPPED)
* [ ] **Evidence schema enforced** (PASS/FAIL/SKIPPED + provenance metadata)
* [ ] **Evidence harness â€œwatch-the-watcherâ€** (integrity checks protect evidence scripts from being neutered)
* [ ] **Compliance mapping exists** (controls mapped to evidence artifacts)
* [ ] **Compliance mapping verified mechanically** (missing evidence references fail)
* [ ] **Policy stubs present** (key mgmt, audit log retention/review, secure SDLC)

### E. Business Foundation Hooks (optional but Tier-1 + commercial readiness)

* [ ] **Billable root hook** (payer vs tenant boundary)
* [ ] **Billing usage ledger** (append-only â€œcash register tapeâ€)
* [ ] **External proofs ledger** (append-only, bound to attestations/instructions)
* [ ] **Correlation stitching** (correlation_id columns present on durable records)
* [ ] **Evidence pack primitives** (grouping + root hash hook)

---

## 2) Gap â†’ Invariant ID â†’ Verifier â†’ Evidence path

Below is a **recommended mapping table**. If your repo already has specific IDs, treat these as â€œproposed IDsâ€ and align them to your numbering scheme when you wire them into `INVARIANTS_MANIFEST.yml` and `phase0_contract.yml`.

### Migration/deployment Tier-1 gates

| Gap                                         | Invariant ID (proposed) | Verifier                                      | Evidence path                                     |
| ------------------------------------------- | ----------------------- | --------------------------------------------- | ------------------------------------------------- |
| No destructive DDL during Expand/Transition | `INV-MIG-001`           | `scripts/db/lint_expand_contract_policy.sh`   | `evidence/phase0/mig_no_destructive_actions.json` |
| Nullability/default safety                  | `INV-MIG-002`           | `scripts/db/lint_expand_contract_policy.sh`   | `evidence/phase0/mig_nullability_default.json`    |
| PK/FK type stability                        | `INV-MIG-003`           | `scripts/db/lint_pk_fk_type_changes.sh`       | `evidence/phase0/mig_pk_fk_type_stability.json`   |
| Baseline provenance seal                    | `INV-GOV-001`           | `scripts/audit/verify_baseline_governance.sh` | `evidence/phase0/baseline_provenance.json`        |
| Local/CI parity is guaranteed               | `INV-GOV-002`           | `scripts/audit/verify_local_ci_parity.sh`     | `evidence/phase0/local_ci_parity.json`            |

### Evidence-grade governance

| Gap                                        | Invariant ID (proposed) | Verifier                                             | Evidence path                                     |
| ------------------------------------------ | ----------------------- | ---------------------------------------------------- | ------------------------------------------------- |
| Evidence files lack provenance metadata    | `INV-EVID-001`          | `scripts/audit/validate_evidence_schema.sh`          | `evidence/phase0/evidence_schema_validation.json` |
| â€œWatch the watcherâ€ not codified           | `INV-EVID-002`          | `scripts/audit/verify_evidence_harness_integrity.sh` | `evidence/phase0/evidence_harness_integrity.json` |
| Compliance mapping exists but not enforced | `INV-COMP-001`          | `scripts/audit/verify_compliance_manifest.sh`        | `evidence/phase0/compliance_manifest.json`        |

### Security/supply-chain Phase-0 gates (single-stack .NET)

| Gap                                      | Invariant ID (proposed) | Verifier                                      | Evidence path                                      |
| ---------------------------------------- | ----------------------- | --------------------------------------------- | -------------------------------------------------- |
| Secrets leakage scan missing             | `INV-SEC-001`           | `scripts/security/scan_secrets.sh`            | `evidence/phase0/security_secrets_scan.json`       |
| .NET dependency integrity missing        | `INV-SEC-002`           | `scripts/security/dotnet_dependency_audit.sh` | `evidence/phase0/security_dotnet_deps_audit.json`  |
| Docker base images not pinned / insecure | `INV-SEC-003`           | `scripts/security/lint_secure_config.sh`      | `evidence/phase0/security_secure_config_lint.json` |
| Insecure patterns in `src/**`            | `INV-SEC-004`           | `scripts/security/lint_insecure_patterns.sh`  | `evidence/phase0/security_insecure_patterns.json`  |

### Business foundation hooks (commercial + audit)

| Gap                              | Invariant ID (proposed) | Verifier                                         | Evidence path                                    |
| -------------------------------- | ----------------------- | ------------------------------------------------ | ------------------------------------------------ |
| Billing usage ledger missing     | `INV-BIZ-001`           | `scripts/db/verify_business_foundation_hooks.sh` | `evidence/phase0/business_foundation_hooks.json` |
| External proofs ledger missing   | `INV-BIZ-002`           | `scripts/db/verify_business_foundation_hooks.sh` | `evidence/phase0/business_foundation_hooks.json` |
| Correlation stitching missing    | `INV-BIZ-003`           | `scripts/db/verify_business_foundation_hooks.sh` | `evidence/phase0/business_foundation_hooks.json` |
| Billable hierarchy missing       | `INV-BIZ-004`           | `scripts/db/verify_business_foundation_hooks.sh` | `evidence/phase0/business_foundation_hooks.json` |
| Evidence pack primitives missing | `INV-BIZ-005`           | `scripts/db/verify_business_foundation_hooks.sh` | `evidence/phase0/business_foundation_hooks.json` |

> Practical note: Itâ€™s okay for one verifier to produce one consolidated evidence file for a cluster, as long as that evidence file lists each required object and you keep gate IDs explicit.

---

## 3) Governance policy stubs (Tier-1 language)

These are written as **Phase-0 policy stubs**: auditor-legible, not over-committing, and compatible with â€œnon-custodial, evidence-gradeâ€ posture.

### A) Key Management Policy Stub

**Path (recommended):** `docs/security/KEY_MANAGEMENT_POLICY.md`

**Contents (stub):**

* **Purpose:** Define how Symphony manages keys used for evidence signing and platform operations.
* **Scope:** Evidence signing keys; TLS/mTLS keys; OpenBao auth roles; CI credentials.
* **Principles:**

  * Keys are never hardcoded in repo.
  * Environments are separated (dev/stage/prod) with distinct key material.
  * Least privilege and separation of duties for key access.
* **Lifecycle:**

  * **Generation:** keys generated in KMS/HSM when available; OpenBao for dev/test.
  * **Storage:** keys stored in OpenBao/KMS; access via workload identity (AppRole/K8s auth).
  * **Rotation:** scheduled rotation cadence (e.g., quarterly for signing keys, annually for CA roots), with emergency rotation procedure.
  * **Revocation/compromise:** immediate revoke â†’ reissue â†’ re-signing policy for evidence manifests (document how â€œold evidence remains verifiableâ€).
* **Auditability:**

  * OpenBao audit logging must be enabled.
  * Key access events are logged and reviewed.
* **Future (explicit):**

  * â€œProduction will migrate to bank-grade HSM/KMS; Phase-0 establishes interfaces and governance.â€

### B) Audit Logging and Retention Policy

**Path (recommended):** `docs/security/AUDIT_LOGGING_AND_RETENTION_POLICY.md`

**Contents (stub):**

* **Purpose:** Define minimum audit logging and retention expectations for Tier-1 audits (PCI/NIST/ISO).
* **What is logged:**

  * OpenBao audit log (auth, secret access)
  * CI gate outcomes (evidence artifacts)
  * DB migration application record + schema fingerprint
* **Integrity & access:**

  * Logs are immutable (WORM target where possible) or append-only with restricted access.
  * Access restricted to security/compliance roles.
* **Retention:**

  * Default retention targets (e.g., 7 years for regulated contexts; Phase-0 uses shorter retention with documented upgrade path).
* **Time sync:**

  * Systems must be time-synchronized (NTP/chrony), and time drift alerts exist (Phase-0: documented requirement).
* **Review cadence:**

  * Security review cadence (daily/weekly) and incident escalation.

### C) Secure SDLC and SAST Readiness Policy

**Path (recommended):** `docs/security/SECURE_SDLC_POLICY.md`

**Contents (stub):**

* **Purpose:** Define minimum secure development controls aligned with OWASP ASVS and PCI DSS Req 6.
* **Required controls in Phase-0:**

  * Mandatory pre-CI checks (`scripts/dev/pre_ci.sh`)
  * CI checks mirror pre-CI entrypoint
  * Secret scanning required
  * Dependency integrity checks required (.NET)
  * Linting checks required (SQL injection heuristics, privilege regressions, DDL risk)
* **SAST posture:**

  * Phase-0: â€œbaseline static checks + readinessâ€
  * Phase-1: integrate deeper SAST (tooling TBD), with evidence artifact export required
* **Change management:**

  * Any waiver requires ADR reference and evidence in PR (explicitly documented)
* **Definition of done:**

  * â€œNo task is completed without PASS evidence matching the evidence contract.â€

---

### Optional but very useful policy stub

**DDL Allowlist Governance Policy** (if not already documented)

* Path: `docs/security/DDL_ALLOWLIST_GOVERNANCE.md`
* Defines how allowlist changes are reviewed and why certain statements are forbidden outside Contract phase.

---

If you re-upload the current manifest/contract/scripts, Iâ€™ll do a second pass that:

* replaces the â€œproposed IDsâ€ with your **actual ID format**
* aligns verifiers to **actual file paths**
* ensures every item is consistent with your **SKIPPED semantics** and current CI wiring.
















Great â€” with the files youâ€™ve attached ( `pre_ci.sh`, `run_*_checks.sh`, `verify_invariants.sh`, `phase0_contract.yml`, and `invariants.yml` ), we can now answer this **concretely and Phase-0-accurately**, not hypothetically.

Below is a **clean, auditor-grade response** in three parts, exactly as requested.

---

# 1ï¸âƒ£ Phase-0 Closeout Checklist (Tier-1 Audit Ready)

This is a **binary checklist**. A Tier-1 auditor should be able to point to each line and see *mechanical enforcement + evidence*.

---

## A. Migration & Deployment Safety (Expand / Contract)

* â˜ **Forward-only migrations enforced**

  * No down migrations
  * Verified by ordered Phase-0 migration runner
* â˜ **N-1 compatibility enforced**

  * Blue code runs against Green schema
  * Verified by `n_minus_one_check`
* â˜ **No destructive DDL during Expand / Transition**

  * `DROP TABLE`, `DROP COLUMN`, `TRUNCATE`, premature contract operations blocked
* â˜ **Nullability safety**

  * No `ADD COLUMN NOT NULL` without `DEFAULT` during Expand
* â˜ **Primary key / foreign key type stability**

  * No `ALTER COLUMN TYPE` on PK/FK
* â˜ **Blocking DDL guarded**

  * Lock-risk lint + allowlist governance
* â˜ **No-TX operations explicitly marked**

  * Concurrent indexes, etc.

---

## B. Core Integrity & State Safety

* â˜ **Append-only ledgers enforced**

  * UPDATE / DELETE prevented by trigger or privilege
* â˜ **Idempotency enforced where required**

  * Instruction / ledger tables safe for retry
* â˜ **Outbox semantics hardened**

  * Pending uniqueness, terminal uniqueness, MVCC posture
* â˜ **Ingress attestation write-before-ACK foundation**
* â˜ **Revocation tables exist**

  * Token / credential revocation supported

---

## C. Security Controls (Phase-0 Appropriate)

* â˜ **Secrets never stored in repo**

  * Secrets scan passes
* â˜ **Secure configuration enforced**

  * Infra / workflow linting
* â˜ **Dependency integrity checked (.NET)**
* â˜ **Secure coding policy enforced**

  * SQL injection heuristics, privilege regression checks
* â˜ **Local == CI parity**

  * Same ordered entrypoint, mechanically verified

---

## D. Evidence-Grade Governance

* â˜ **Evidence contract enforced**

  * Completed tasks â†’ PASS evidence
  * Planned tasks â†’ SKIPPED evidence
* â˜ **Evidence schema enforced**

  * PASS / FAIL / SKIPPED
  * Timestamp, git SHA, inputs
* â˜ **Watch-the-watcher enforced**

  * Evidence scripts protected from silent bypass
* â˜ **Compliance mapping exists**

  * PCI / NIST / OWASP / ISO mapped
* â˜ **Compliance mapping verified mechanically**

---

## E. Governance Policies (Phase-0 Stubs)

* â˜ **Key Management Policy exists**
* â˜ **Audit Logging & Retention Policy exists**
* â˜ **Secure SDLC Policy exists**
* â˜ **DDL Allowlist Governance documented**
* â˜ **Proxy-resolution ADR exists**

---

## F. Business Foundation Hooks (Optional but Tier-1-Positive)

* â˜ **Billable client hierarchy hook**
* â˜ **Billing usage ledger (append-only)**
* â˜ **External proof ledger**
* â˜ **Correlation stitching (`correlation_id`)**
* â˜ **Evidence pack primitives**

---

# 2ï¸âƒ£ Gap â†’ Invariant â†’ Verifier â†’ Evidence Mapping

This table reflects **your current repo structure** (bash-based gates, invariant manifest, Phase-0 contract).

> IDs marked **(NEW)** are not currently enforced and must be added to reach Tier-1.

---

## Migration / Expand-Contract Gaps

| Gap                              | Invariant ID          | Verifier                                    | Evidence                                          |
| -------------------------------- | --------------------- | ------------------------------------------- | ------------------------------------------------- |
| No destructive DDL during Expand | **INV-MIG-001 (NEW)** | `scripts/db/lint_expand_contract_policy.sh` | `evidence/phase0/mig_no_destructive_actions.json` |
| Nullability / default safety     | **INV-MIG-002 (NEW)** | `scripts/db/lint_expand_contract_policy.sh` | `evidence/phase0/mig_nullability_default.json`    |
| PK / FK type stability           | **INV-MIG-003 (NEW)** | `scripts/db/lint_pk_fk_type_changes.sh`     | `evidence/phase0/mig_pk_fk_type_stability.json`   |
| Baseline provenance              | INV-013               | `verify_baseline_governance.sh`             | `baseline_drift.json`                             |
| Ordered migration discipline     | INV-028               | `run_phase0_ordered_checks.sh`              | `phase0_impl_plan.json`                           |

---

## Evidence & Governance Gaps

| Gap                            | Invariant ID           | Verifier                           | Evidence                          |
| ------------------------------ | ---------------------- | ---------------------------------- | --------------------------------- |
| Evidence schema consistency    | **INV-EVID-001 (NEW)** | `validate_evidence_schema.sh`      | `evidence_schema_validation.json` |
| Evidence harness integrity     | INV-011                | `verify_task_evidence_contract.sh` | `evidence_validation.json`        |
| Local / CI parity              | INV-036                | `verify_local_ci_parity.sh`        | `local_ci_parity.json`            |
| Compliance mapping enforcement | **INV-COMP-001 (NEW)** | `verify_compliance_manifest.sh`    | `compliance_manifest.json`        |

---

## Security & Supply Chain

| Gap               | Invariant ID          | Verifier                     | Evidence                           |
| ----------------- | --------------------- | ---------------------------- | ---------------------------------- |
| Secrets leakage   | INV-024               | `scan_secrets.sh`            | `security_secrets_scan.json`       |
| Secure config     | INV-026               | `lint_secure_config.sh`      | `security_secure_config_lint.json` |
| .NET dependencies | **INV-SEC-002 (NEW)** | `dotnet_dependency_audit.sh` | `security_dotnet_deps_audit.json`  |
| Insecure patterns | INV-026               | `lint_insecure_patterns.sh`  | `security_insecure_patterns.json`  |

---

## Business Foundation (if implemented)

| Gap                   | Invariant ID          | Verifier                              | Evidence                         |
| --------------------- | --------------------- | ------------------------------------- | -------------------------------- |
| Billing usage ledger  | **INV-BIZ-001 (NEW)** | `verify_business_foundation_hooks.sh` | `business_foundation_hooks.json` |
| External proofs       | **INV-BIZ-002 (NEW)** | same                                  | same                             |
| Correlation stitching | **INV-BIZ-003 (NEW)** | same                                  | same                             |
| Billable hierarchy    | **INV-BIZ-004 (NEW)** | same                                  | same                             |

---

# 3ï¸âƒ£ Governance Policy Stubs (Tier-1 Language)

These are **Phase-0 stubs**: auditor-legible, intentionally scoped, and future-compatible.

---

## A. Key Management Policy

**Path:** `docs/security/KEY_MANAGEMENT_POLICY.md`

**Purpose**
Define how cryptographic keys used by Symphony are generated, stored, rotated, and audited.

**Scope**
Evidence-signing keys, service credentials, TLS/mTLS material, CI secrets.

**Policy**

* Keys are never stored in source control.
* Keys are managed via OpenBao in Phase-0.
* Access is identity-based (AppRole / workload identity).
* Separation of duties is enforced between operators and developers.

**Lifecycle**

* Generation: performed in OpenBao or external KMS/HSM.
* Storage: encrypted at rest; access logged.
* Rotation: defined cadence (documented), emergency rotation supported.
* Revocation: compromised keys revoked immediately; evidence remains verifiable.

**Audit**

* All key access is logged.
* Logs are reviewed on a defined cadence.

**Phase-1 Note**
Production deployments may migrate to bank-grade HSM/KMS without schema changes.

---

## B. Audit Logging & Retention Policy

**Path:** `docs/security/AUDIT_LOGGING_AND_RETENTION_POLICY.md`

**Purpose**
Ensure traceability and forensic reconstruction for regulatory review.

**What Is Logged**

* OpenBao audit logs
* CI invariant and security gate outcomes
* Schema migration execution + fingerprints

**Integrity**

* Logs are append-only or WORM-anchored where feasible.
* Access restricted to security and compliance roles.

**Retention**

* Default target: 7 years (configurable by regulator).
* Phase-0 uses shorter retention with documented upgrade path.

**Time**

* Systems must be time-synchronized (NTP).
* Time drift is monitored.

---

## C. Secure SDLC Policy

**Path:** `docs/security/SECURE_SDLC_POLICY.md`

**Purpose**
Define minimum security controls for software development and delivery.

**Requirements**

* Mandatory pre-CI checks (`pre_ci.sh`)
* CI must execute the same ordered checks
* Secrets scanning required
* Dependency integrity checks required
* Secure coding policy enforced

**SAST**

* Phase-0: baseline static checks + readiness
* Phase-1: deeper SAST with exported evidence artifacts

**Change Control**

* Any waiver requires ADR reference and evidence.

---

## D. DDL Allowlist Governance

**Path:** `docs/security/DDL_ALLOWLIST_GOVERNANCE.md`

**Policy**

* Only allowlisted DDL may be used in Phase-0.
* Contract-phase operations require explicit marker + ADR.
* Allowlist changes require review and evidence.

---

## E. Proxy Resolution ADR

**Path:** `docs/architecture/ADR-00XX-proxy-resolution.md`

**Decision**
Whether identity aliases (TPIN / MSISDN) are resolved before or after enqueue.

**Rationale**
Prevents ghost beneficiaries and supports IPDR evidence stitching.

---

# Final Verdict

* Your **current Phase-0 posture is strong**.
* To be **Tier-1 audit ready**, the missing pieces are:

  * explicit Expand/Contract PaC invariants
  * evidence schema enforcement
  * governance policy stubs
* None of these require runtime coupling.
* All are compatible with your existing invariant/evidence architecture.

If you want, next I can:

* generate the **exact invariant manifest entries** for the NEW invariants, or
* produce the **policy-lint scripts** in your repo style, or
* turn this into a **Phase-0 Closeout Report** suitable for a regulator or bank pre-audit.












This is **very close** to â€œall-inclusive and ready,â€ and itâ€™s structured in the right Phase-0 way (mechanical gates first, forward-only, no runtime coupling). There are a few **Tier-1 closeout items** that are either missing explicitly or are currently implied but not guaranteed as *mechanically enforced gates with evidence*.

Below is a tight review: whatâ€™s solid, whatâ€™s missing, and the exact adjustments that would make this plan â€œTier-1-readyâ€ as written.

---

## Whatâ€™s already strong and â€œreadyâ€

* **Workstream layout is correct**: governance stubs + verifiers, migration PaC lints, catalog-based conventions, wiring.
* **Non-goals are correctly stated** (no claims of certification, no Phase-1/2 runtime, no cleanup).
* **Acceptance criteria is Phase-0 accurate**: invariants, verifiers, evidence, wiring.
* **Verification commands list is correct**, but needs one or two additional checks (see below).

---

## Gaps to fix before calling it â€œall-inclusiveâ€

### 1) Evidence reproducibility upgrades need an explicit â€œevidence schemaâ€ gate

You mention â€œEvidence reproducibility upgradesâ€ in scope, but thereâ€™s **no task** that ensures evidence JSON includes:

* `status: PASS|FAIL|SKIPPED`
* `git_sha`
* `inputs_scanned` (files, tables, etc.)
* `timestamp`
* optional `schema_fingerprint`

âœ… **Add one task**

* **TSK-P0-100: Evidence schema + validator**

  * Deliver: `docs/architecture/evidence_schema.json` (or `.yml`)
  * Deliver: `scripts/audit/validate_evidence_schema.sh`
  * Evidence: `evidence/phase0/evidence_schema_validation.json`
  * Wire into pre-CI + CI

This is what turns â€œwe produce evidenceâ€ into â€œevidence is audit-grade.â€

---

### 2) â€œWatch-the-watcherâ€ isnâ€™t explicitly in the plan

Your audit gap summary repeatedly flags the risk that evidence scripts can be weakened. Your plan doesnâ€™t include a dedicated integrity gate for the evidence harness itself.

âœ… **Add one task**

* **TSK-P0-101: Evidence harness integrity (â€œwatch-the-watcherâ€)**

  * Verifies:

    * evidence-gate scripts exist and are executable
    * they fail on violations (no silent `|| true`, no â€œalways passâ€ pattern)
    * they write evidence on failure as well as success
  * Evidence: `evidence/phase0/evidence_harness_integrity.json`

This is a Tier-1 â€œcontrols over controlsâ€ item.

---

### 3) Compliance mapping enforcement is missing (unless itâ€™s already implemented elsewhere)

You included governance stubs, but the closeout also needs:

* `SECURITY_MANIFEST.yml` (or equivalent)
* a verifier that fails if controls donâ€™t map to evidence artifacts, or if mapped evidence paths donâ€™t exist

âœ… **Add one task**

* **TSK-P0-102: Compliance manifest + mechanical verifier**

  * Deliver: `docs/security/SECURITY_MANIFEST.yml` (if not already)
  * Deliver: `scripts/audit/verify_compliance_manifest.sh`
  * Evidence: `evidence/phase0/compliance_manifest.json`
  * Wire into CI/pre-CI

Without this, you still have â€œdocumented compliance,â€ not enforced compliance.

---

### 4) Supply-chain / dependency integrity for .NET is not in this plan (unless already done)

Your Workstream A includes SDLC + â€œSAST readiness,â€ but the earlier gap analysis included supply chain controls. Since this is a single-stack .NET backend, you should treat this as:

* lockfile / assets consistency check
* banned packages/licenses list (optional)
* Docker base image pinning (if Dockerfiles exist)
* â€œno unreviewed feed sourcesâ€ check (NuGet.config)

âœ… **Add one task (Phase-0-safe)**

* **TSK-P0-103: .NET dependency integrity gate**

  * Verifier: `scripts/security/dotnet_dependency_audit.sh`
  * Evidence: `evidence/phase0/security_dotnet_deps_audit.json`
  * Inputs: `.csproj`, `Directory.Packages.props`, `packages.lock.json`, `NuGet.config` (if present)

(If you already have this under existing tasks, explicitly reference it in this closeout plan.)

---

### 5) DDL allowlist governance is not explicitly included

Your plan has expand/contract guardrails + PK/FK type lint, but Tier-1 reviewers also look for:

* allowlist changes are governed (review + evidence)
* migrations cannot introduce forbidden statements even if lock-risk lint misses them

âœ… If not already in your repo, add:

* **TSK-P0-104: DDL allowlist governance verifier**

  * Verifier: `scripts/audit/verify_ddl_allowlist_governance.sh`
  * Evidence: `evidence/phase0/ddl_allowlist_governance.json`

If it already exists, reference it explicitly under Workstream B.

---

### 6) ISO 20022 closeout hooks need one more explicit artifact

Your Workstream F says â€œdefine message contract registry location and validation expectations,â€ but to be tight you want:

* a declared **registry path**
* a gate that asserts the registry exists + is referenced in docs/manifest + is not empty (or is explicitly `SKIPPED` until Phase-1)

âœ… Tighten TSK-P0-099 to include:

* `docs/iso20022/MESSAGE_CONTRACT_REGISTRY.yml` (or `docs/iso20022/contracts/`)
* verifier `scripts/audit/verify_iso20022_contract_registry.sh`
* evidence `evidence/phase0/iso20022_registry_presence.json`

---

## Recommended edits to your plan text

### Add to Workstream D (Verification list)

Right now you list:

* `run_invariants_fast_checks`
* `run_security_fast_checks`
* `verify_invariants`
* `verify_phase0_contract`

Add:

* `scripts/audit/validate_evidence_schema.sh` (if you accept TSK-P0-100)
* `scripts/audit/verify_compliance_manifest.sh` (if you accept TSK-P0-102)

### Tighten Workstream E (Business hooks reconciliation)

TSK-P0-098 should not only â€œreconcile status,â€ it must also:

* ensure there is a **single verifier** for the hooks (e.g., `verify_business_foundation_hooks.sh`)
* ensure the evidence is in contract and matches SKIPPED/PASS semantics

If business hooks are already implemented, this becomes a closeout â€œtruth alignmentâ€ task:

* update contract entries â†’ PASS evidence required and present

---

## Bottom line

Your plan is **almost all-inclusive**. To make it truly Tier-1 closeout-ready, add explicit tasks for:

1. **Evidence schema validation** (reproducibility gate)
2. **Watch-the-watcher** (evidence harness integrity)
3. **Compliance manifest enforcement**
4. **.NET dependency integrity** (if not already implemented)
5. **DDL allowlist governance** (if not already implemented)
6. **ISO 20022 registry presence gate** (tighten Workstream F)

If you want, paste your current invariant ID ranges (or your manifest snippet), and Iâ€™ll propose exact invariant IDs that match your numbering scheme (so you donâ€™t introduce a second â€œID styleâ€).










Yep â€” based on your current `INVARIANTS_MANIFEST.yml`, you **already cover** parts of this *indirectly* (e.g., **N-1 compatibility**, **forward-only migrations**, **DDL lock-risk lint**, **no runtime DDL**), but you **do not yet have explicit Phase-0 PaC lints** that mechanically enforce:

* **No destructive DDL during Expand/Transition** (DROP COLUMN/TABLE, etc., unless explicitly marked â€œcleanup/contractâ€)
* **ADD COLUMN safety** (no `NOT NULL` without `DEFAULT`)
* **PK/FK type stability** (forbid `ALTER COLUMN ... TYPE` on PK/FK)
* **table-class conventions** like **idempotency_key** and **audit lineage columns** for new â€œledger/txnâ€ tables

So: you should add **new invariants** for those.

Below are **exact manifest entries** for the *NEW* invariants to append to `docs/invariants/INVARIANTS_MANIFEST.yml` (continuing after `INV-096`, matching your repo style: `id/aliases/status/severity/title/owners/sla_days/verification`).

---

## Patch snippet: append these to `INVARIANTS_MANIFEST.yml`

```yaml
- id: INV-097
  aliases: ["I-MIG-PAC-01"]
  status: roadmap
  severity: P0
  title: "Expand/Transition migrations forbid destructive DDL unless explicitly marked as Contract cleanup"
  owners: ["team-db", "team-platform"]
  sla_days: 14
  verification: "scripts/db/lint_expand_contract_ddl.sh; run via scripts/db/verify_invariants.sh"

- id: INV-098
  aliases: ["I-MIG-PAC-02"]
  status: roadmap
  severity: P0
  title: "ADD COLUMN must be nullable or have DEFAULT (no NOT NULL without DEFAULT during Expand)"
  owners: ["team-db"]
  sla_days: 14
  verification: "scripts/db/lint_expand_contract_ddl.sh (ADD COLUMN rules); run via scripts/db/verify_invariants.sh"

- id: INV-099
  aliases: ["I-MIG-PAC-03"]
  status: roadmap
  severity: P0
  title: "Primary key / foreign key type stability (forbid ALTER COLUMN TYPE on PK/FK)"
  owners: ["team-db"]
  sla_days: 14
  verification: "scripts/db/lint_pk_fk_type_changes.sh; run via scripts/db/verify_invariants.sh"

- id: INV-100
  aliases: ["I-TBL-CONV-01"]
  status: roadmap
  severity: P1
  title: "Ledger/transaction table conventions enforced (idempotency_key + lineage columns by class)"
  owners: ["team-db", "team-platform"]
  sla_days: 30
  verification: "scripts/db/verify_table_conventions.sh; run via scripts/db/verify_invariants.sh"

- id: INV-101
  aliases: ["I-EVID-HARNESS-01"]
  status: roadmap
  severity: P0
  title: "Evidence harness integrity (watch-the-watcher): gates must fail-closed and emit evidence on FAIL/SKIPPED"
  owners: ["team-platform"]
  sla_days: 14
  verification: "scripts/audit/verify_evidence_harness_integrity.sh; run via scripts/audit/run_invariants_fast_checks.sh"
```

---

## How these map to the 5 PaC items you listed

1. **No-Destructive-Action** â†’ `INV-097`
2. **Nullability & Default** â†’ `INV-098`
3. **Idempotency Key** â†’ `INV-100` (table-class convention: ledger/txn tables must include `idempotency_key` + uniqueness)
4. **Audit & Lineage (â€œBig Threeâ€)** â†’ `INV-100` (requires `created_at`, `updated_at`, `version_id` by class)
5. **PK Stability** â†’ `INV-099`

> Note: You donâ€™t need OPA/Sentinel in Phase-0 to get Tier-1 mechanical value; you can implement the same policies as repo-native lints now and later port the rules to OPA if/when you introduce IaC policy enforcement.

---

If you want me to do **option 2** next (produce the actual scripts in your repo style), Iâ€™ll generate:

* `scripts/db/lint_expand_contract_ddl.sh`
* `scripts/db/lint_pk_fk_type_changes.sh`
* `scripts/db/verify_table_conventions.sh`
* `scripts/audit/verify_evidence_harness_integrity.sh`

â€¦and wire them into `verify_invariants.sh` / fast checks with deterministic evidence outputs matching your SKIPPED semantics.









```diff
diff --git a/scripts/db/lint_expand_contract_guardrails.sh b/scripts/db/lint_expand_contract_guardrails.sh
new file mode 100755
index 0000000..c0a6a43
--- /dev/null
+++ b/scripts/db/lint_expand_contract_guardrails.sh
@@ -0,0 +1,193 @@
+#!/usr/bin/env bash
+# ============================================================
+# lint_expand_contract_guardrails.sh
+#
+# Phase-0 migration guardrails for Expand/Contract discipline.
+#
+# Enforces (fail-closed):
+#   1) No destructive actions in Expand/Transition unless explicitly marked.
+#      - DROP TABLE / DROP COLUMN / TRUNCATE / ALTER TABLE ... DROP ...
+#   2) Add-column N-1 safety:
+#      - Reject "ADD COLUMN ... NOT NULL" unless the statement includes DEFAULT.
+#
+# Marker to allow destructive cleanup (Contract phase only):
+#   -- symphony:contract_cleanup
+#
+# Evidence:
+#   evidence/phase0/expand_contract_guardrails.json
+# ============================================================
+set -euo pipefail
+
+ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"
+MIG_DIR="$ROOT_DIR/schema/migrations"
+EVIDENCE_DIR="$ROOT_DIR/evidence/phase0"
+EVIDENCE_FILE="$EVIDENCE_DIR/expand_contract_guardrails.json"
+
+mkdir -p "$EVIDENCE_DIR"
+source "$ROOT_DIR/scripts/lib/evidence.sh"
+
+EVIDENCE_TS="$(evidence_now_utc)"
+EVIDENCE_GIT_SHA="$(git_sha)"
+EVIDENCE_SCHEMA_FP="$(schema_fingerprint)"
+
+status="PASS"
+violations_json="[]"
+file_count=0
+
+if [[ ! -d "$MIG_DIR" ]]; then
+  status="SKIPPED"
+else
+  py_out="$(
+    python3 - "$MIG_DIR" <<'PY'
+import json, os, re, sys
+mig_dir = sys.argv[1]
+
+# Very small SQL splitter: splits on semicolons outside dollar-quoted blocks.
+tag_re = re.compile(r'\$[A-Za-z0-9_]*\$')
+
+def split_statements(sql: str):
+    out = []
+    buf = []
+    tag = None
+    i = 0
+    while i < len(sql):
+        ch = sql[i]
+        if ch == '$':
+            m = tag_re.match(sql, i)
+            if m:
+                t = m.group(0)
+                if tag is None:
+                    tag = t
+                elif tag == t:
+                    tag = None
+                buf.append(t)
+                i += len(t)
+                continue
+        if ch == ';' and tag is None:
+            stmt = ''.join(buf).strip()
+            if stmt:
+                out.append(stmt)
+            buf = []
+            i += 1
+            continue
+        buf.append(ch)
+        i += 1
+    tail = ''.join(buf).strip()
+    if tail:
+        out.append(tail)
+    return out
+
+def has_cleanup_marker(sql: str) -> bool:
+    head = '\n'.join(sql.splitlines()[:40])
+    return '-- symphony:contract_cleanup' in head
+
+destructive_re = re.compile(r'\b(drop\s+table|drop\s+column|truncate\b|alter\s+table\b[^\n;]*\bdrop\b)', re.I)
+addcol_notnull_re = re.compile(r'\balter\s+table\b.*\badd\s+column\b.*\bnot\s+null\b', re.I | re.S)
+default_re = re.compile(r'\bdefault\b', re.I)
+
+violations = []
+files = [os.path.join(mig_dir, f) for f in os.listdir(mig_dir) if f.endswith('.sql')]
+files.sort()
+
+for path in files:
+    try:
+        sql = open(path, 'r', encoding='utf-8', errors='ignore').read()
+    except Exception as e:
+        violations.append({"file": os.path.relpath(path, mig_dir), "rule": "READ_ERROR", "detail": str(e)})
+        continue
+
+    allow_cleanup = has_cleanup_marker(sql)
+    stmts = split_statements(sql)
+    for idx, stmt in enumerate(stmts, 1):
+        s = re.sub(r'--.*?$', '', stmt, flags=re.M).strip()
+        if not s:
+            continue
+
+        if destructive_re.search(s) and not allow_cleanup:
+            snippet = ' '.join(s.split())
+            if len(snippet) > 240:
+                snippet = snippet[:237] + '...'
+            violations.append({
+                "file": os.path.relpath(path, mig_dir),
+                "statement_index": idx,
+                "rule": "NO_DESTRUCTIVE_DDL_WITHOUT_CONTRACT_CLEANUP",
+                "detail": snippet
+            })
+
+        if addcol_notnull_re.search(s) and not default_re.search(s):
+            snippet = ' '.join(s.split())
+            if len(snippet) > 240:
+                snippet = snippet[:237] + '...'
+            violations.append({
+                "file": os.path.relpath(path, mig_dir),
+                "statement_index": idx,
+                "rule": "ADD_COLUMN_NOT_NULL_REQUIRES_DEFAULT",
+                "detail": snippet
+            })
+
+print(json.dumps({"file_count": len(files), "violations": violations}))
+PY
+  )"
+
+  file_count="$(python3 -c 'import json,sys; d=json.load(sys.stdin); print(d.get("file_count",0))' <<<"$py_out")"
+  violations_json="$(python3 -c 'import json,sys; d=json.load(sys.stdin); print(json.dumps(d.get("violations",[]), indent=2))' <<<"$py_out")"
+  vcount="$(python3 -c 'import json,sys; d=json.load(sys.stdin); print(len(d.get("violations",[])))' <<<"$py_out")"
+  if [[ "$vcount" != "0" ]]; then
+    status="FAIL"
+  fi
+fi
+
+write_json "$EVIDENCE_FILE" \
+  "\"check_id\": \"INV-EC-01\"" \
+  "\"timestamp_utc\": \"${EVIDENCE_TS}\"" \
+  "\"git_sha\": \"${EVIDENCE_GIT_SHA}\"" \
+  "\"schema_fingerprint\": \"${EVIDENCE_SCHEMA_FP}\"" \
+  "\"status\": \"${status}\"" \
+  "\"migrations_dir\": \"schema/migrations\"" \
+  "\"file_count\": ${file_count}" \
+  "\"violations\": ${violations_json}"
+
+if [[ "$status" == "FAIL" ]]; then
+  echo "âŒ Expand/Contract guardrails failed. Evidence: $EVIDENCE_FILE"
+  exit 1
+fi
+
+echo "âœ… Expand/Contract guardrails: ${status}. Evidence: $EVIDENCE_FILE"
+
diff --git a/scripts/db/lint_pk_fk_type_stability.sh b/scripts/db/lint_pk_fk_type_stability.sh
new file mode 100755
index 0000000..9f7b5a1
--- /dev/null
+++ b/scripts/db/lint_pk_fk_type_stability.sh
@@ -0,0 +1,170 @@
+#!/usr/bin/env bash
+# ============================================================
+# lint_pk_fk_type_stability.sh
+#
+# Phase-0 migration guardrail: forbid ALTER COLUMN TYPE by default.
+#
+# Why (Tier-1): PK/FK type churn breaks blue/green compatibility and dual-write.
+# In Phase-0 we implement the conservative superset rule:
+#   - any ALTER TABLE ... ALTER COLUMN ... TYPE is rejected
+#   - unless explicitly waived with an ADR reference
+#
+# Waiver marker (must be in first ~40 lines of the migration):
+#   -- symphony:allow_type_change adr=docs/adr/ADR-XXXX.md
+#
+# Evidence:
+#   evidence/phase0/pk_fk_type_stability.json
+# ============================================================
+set -euo pipefail
+
+ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"
+MIG_DIR="$ROOT_DIR/schema/migrations"
+EVIDENCE_DIR="$ROOT_DIR/evidence/phase0"
+EVIDENCE_FILE="$EVIDENCE_DIR/pk_fk_type_stability.json"
+
+mkdir -p "$EVIDENCE_DIR"
+source "$ROOT_DIR/scripts/lib/evidence.sh"
+
+EVIDENCE_TS="$(evidence_now_utc)"
+EVIDENCE_GIT_SHA="$(git_sha)"
+EVIDENCE_SCHEMA_FP="$(schema_fingerprint)"
+
+status="PASS"
+violations_json="[]"
+file_count=0
+
+if [[ ! -d "$MIG_DIR" ]]; then
+  status="SKIPPED"
+else
+  py_out="$(
+    python3 - "$MIG_DIR" <<'PY'
+import json, os, re, sys
+mig_dir = sys.argv[1]
+
+alter_type_re = re.compile(r'\balter\s+table\b.*\balter\s+column\b.*\btype\b', re.I | re.S)
+waiver_re = re.compile(r'--\s*symphony:allow_type_change\s+adr=([^\s]+)', re.I)
+
+violations = []
+files = [os.path.join(mig_dir, f) for f in os.listdir(mig_dir) if f.endswith('.sql')]
+files.sort()
+
+for path in files:
+    sql = open(path, 'r', encoding='utf-8', errors='ignore').read()
+    head = '\n'.join(sql.splitlines()[:40])
+    waiver = waiver_re.search(head)
+    adr = waiver.group(1) if waiver else None
+
+    if alter_type_re.search(sql):
+        if not adr:
+            violations.append({
+                "file": os.path.relpath(path, mig_dir),
+                "rule": "FORBID_ALTER_COLUMN_TYPE_WITHOUT_WAIVER",
+                "detail": "ALTER COLUMN TYPE detected. Add waiver marker with ADR ref if truly required."
+            })
+        else:
+            # Allowed but recorded (auditors will ask why)
+            violations.append({
+                "file": os.path.relpath(path, mig_dir),
+                "rule": "WAIVED_ALTER_COLUMN_TYPE",
+                "adr": adr,
+                "detail": "ALTER COLUMN TYPE detected but waived via ADR reference."
+            })
+
+print(json.dumps({"file_count": len(files), "violations": violations}))
+PY
+  )"
+
+  file_count="$(python3 -c 'import json,sys; d=json.load(sys.stdin); print(d.get("file_count",0))' <<<"$py_out")"
+  violations_json="$(python3 -c 'import json,sys; d=json.load(sys.stdin); print(json.dumps(d.get("violations",[]), indent=2))' <<<"$py_out")"
+  vcount="$(python3 -c 'import json,sys; d=json.load(sys.stdin); print(len(d.get("violations",[])))' <<<"$py_out")"
+
+  # If there are any non-waived violations, FAIL.
+  non_waived="$(python3 -c 'import json,sys; d=json.load(sys.stdin); print(sum(1 for v in d.get("violations",[]) if v.get("rule")=="FORBID_ALTER_COLUMN_TYPE_WITHOUT_WAIVER"))' <<<"$py_out")"
+  if [[ "$non_waived" != "0" ]]; then
+    status="FAIL"
+  fi
+fi
+
+write_json "$EVIDENCE_FILE" \
+  "\"check_id\": \"INV-PK-01\"" \
+  "\"timestamp_utc\": \"${EVIDENCE_TS}\"" \
+  "\"git_sha\": \"${EVIDENCE_GIT_SHA}\"" \
+  "\"schema_fingerprint\": \"${EVIDENCE_SCHEMA_FP}\"" \
+  "\"status\": \"${status}\"" \
+  "\"migrations_dir\": \"schema/migrations\"" \
+  "\"file_count\": ${file_count}" \
+  "\"violations\": ${violations_json}"
+
+if [[ "$status" == "FAIL" ]]; then
+  echo "âŒ PK/FK type stability lint failed. Evidence: $EVIDENCE_FILE"
+  exit 1
+fi
+
+echo "âœ… PK/FK type stability lint: ${status}. Evidence: $EVIDENCE_FILE"
+
diff --git a/scripts/audit/run_invariants_fast_checks.sh b/scripts/audit/run_invariants_fast_checks.sh
index 6c4a1b7..d6c25e4 100755
--- a/scripts/audit/run_invariants_fast_checks.sh
+++ b/scripts/audit/run_invariants_fast_checks.sh
@@ -140,6 +140,30 @@ echo "==> YAML conventions lint"
   exit 1
 fi
 
+echo ""
+echo "==> Expand/Contract guardrails (migration lint)"
+if [[ -x "scripts/db/lint_expand_contract_guardrails.sh" || -f "scripts/db/lint_expand_contract_guardrails.sh" ]]; then
+  run bash scripts/db/lint_expand_contract_guardrails.sh
+else
+  echo "ERROR: scripts/db/lint_expand_contract_guardrails.sh not found"
+  exit 1
+fi
+
+echo ""
+echo "==> PK/FK type stability lint (migration lint)"
+if [[ -x "scripts/db/lint_pk_fk_type_stability.sh" || -f "scripts/db/lint_pk_fk_type_stability.sh" ]]; then
+  run bash scripts/db/lint_pk_fk_type_stability.sh
+else
+  echo "ERROR: scripts/db/lint_pk_fk_type_stability.sh not found"
+  exit 1
+fi
+
 echo ""
 echo "==> No-tx docs verification"
 if [[ -x "scripts/audit/verify_no_tx_docs.sh" || -f "scripts/audit/verify_no_tx_docs.sh" ]]; then
   run scripts/audit/verify_no_tx_docs.sh
```

**Notes (so it matches your Phase-0 semantics + repo style):**

* Both scripts **always emit evidence** and fail closed only on real violations.
* They use the same `scripts/lib/evidence.sh` helpers you already use (timestamp/git sha/schema fp, `write_json`).
* `lint_pk_fk_type_stability.sh` is intentionally conservative in Phase-0: it forbids *any* `ALTER COLUMN TYPE` unless explicitly waived with an ADR reference marker (this is safer than trying to infer PK/FK membership from raw SQL text).

If you want, I can also add the corresponding `docs/invariants/INVARIANTS_MANIFEST.yml` entries (`INV-EC-01`, `INV-PK-01`) and map the evidence paths so the manifest + contract are fully consistent.


















Below are **non-colliding, next-available invariant IDs** (since your manifest already has INV-081 and then jumps to INV-090+), plus **minimal patch snippets** that (a) put the new entries in the right place in `INVARIANTS_MANIFEST.yml`, and (b) update `phase0_contract.yml` so your contract verifier + **SKIPPED semantics script** stay consistent.

---

## 1) Next invariant IDs (no collision)

From your attached `INVARIANTS_MANIFEST.yml`, **INV-082 .. INV-089 are currently unused**, while INV-090+ are already allocated to Business Foundation.

So the next safe IDs for the new closeout work are:

* **INV-082** â€” Expand/Contract migration guardrails (no destructive DDL + nullable/default safety)
* **INV-083** â€” PK/FK type stability lint (no ALTER TYPE on keys; waiver via ADR marker)
* **INV-084** â€” Table conventions verifier (catalog-based: required cols/constraints by table class)

These fit cleanly **after INV-081** and before the Business Foundation block (INV-090+).

---

## 2) Patch snippet: `INVARIANTS_MANIFEST.yml`

Insert **immediately after the INV-081 block** (i.e., before `- id: INV-090`):

```diff
diff --git a/INVARIANTS_MANIFEST.yml b/INVARIANTS_MANIFEST.yml
index 0000000..0000000 100644
--- a/INVARIANTS_MANIFEST.yml
+++ b/INVARIANTS_MANIFEST.yml
@@ -445,6 +445,30 @@
   severity: P1
   title: Control planes - defined and enforced
   owners:
     - team-platform
   sla_days: 30
   verification: scripts/audit/verify_control_planes_drift.sh
+- id: INV-082
+  aliases: []
+  status: planned
+  severity: P1
+  title: Expand/Contract migration guardrails enforced
+  owners:
+    - team-platform
+  sla_days: 30
+  verification: scripts/security/lint_expand_contract_guardrails.sh
+- id: INV-083
+  aliases: []
+  status: planned
+  severity: P1
+  title: PK/FK type stability enforced during migrations
+  owners:
+    - team-platform
+  sla_days: 30
+  verification: scripts/security/lint_pk_fk_type_stability.sh
+- id: INV-084
+  aliases: []
+  status: planned
+  severity: P2
+  title: Table conventions verified via pg_catalog
+  owners:
+    - team-platform
+  sla_days: 30
+  verification: scripts/db/verify_table_conventions.sh
 - id: INV-090
   aliases: []
   status: planned
   severity: P1
   title: Billing usage ledger exists and is append-only
```

**Why this placement is â€œrightâ€:** it keeps â€œcontrol-plane / migration governanceâ€ invariants grouped (70â€“80s) and leaves 90+ as your Business Foundation cluster.

---

## 3) Patch snippet: `phase0_contract.yml` (contract ordering + SKIPPED semantics compatible)

Your `verify_phase0_contract_evidence_status.sh` only enforces evidence status semantics for rows that have **`gate_ids` populated**. Right now TSK-P0-093..095 have `gate_ids: []`, which is good (you havenâ€™t created CONTROL_PLANES yet). So the **only safe alignment change now** is to set the contract to declare the intended evidence outputs (without forcing evidence to exist yet).

Patch:

```diff
diff --git a/phase0_contract.yml b/phase0_contract.yml
index 0000000..0000000 100644
--- a/phase0_contract.yml
+++ b/phase0_contract.yml
@@ -1076,10 +1076,12 @@
   {
     "task_id": "TSK-P0-093",
     "status": "planned",
     "verification_mode": "both",
-    "evidence_required": false,
-    "evidence_paths": [],
+    "evidence_required": true,
+    "evidence_paths": [
+      "evidence/phase0/migration_expand_contract_guardrails.json"
+    ],
     "evidence_scope": "repo",
     "notes": "Expand/contract migration guardrail lint planned (no destructive DDL; nullability safety).",
     "gate_ids": []
   },
@@ -1087,10 +1089,12 @@
   {
     "task_id": "TSK-P0-094",
     "status": "planned",
     "verification_mode": "both",
-    "evidence_required": false,
-    "evidence_paths": [],
+    "evidence_required": true,
+    "evidence_paths": [
+      "evidence/phase0/migration_pk_fk_type_stability.json"
+    ],
     "evidence_scope": "repo",
     "notes": "PK/FK type stability lint planned (ADR waiver marker).",
     "gate_ids": []
   },
@@ -1098,10 +1102,12 @@
   {
     "task_id": "TSK-P0-095",
     "status": "planned",
     "verification_mode": "both",
-    "evidence_required": false,
-    "evidence_paths": [],
+    "evidence_required": true,
+    "evidence_paths": [
+      "evidence/phase0/table_conventions.json"
+    ],
     "evidence_scope": "repo",
     "notes": "Table conventions spec + catalog verifier planned.",
     "gate_ids": []
   },
```

### Why this matches your enforcement scripts **exactly**

* `verify_phase0_contract.sh` requires: if `evidence_required=true`, then `evidence_paths` must be non-empty âœ…
* `verify_phase0_contract_evidence_status.sh` only requires evidence files/status **when `gate_ids` exist** âœ… (youâ€™re leaving them empty until CONTROL_PLANES + gates land)
* Ordering stays correct because weâ€™re not moving entries, only editing fields âœ…

---

## Practical note for later (when CONTROL_PLANES exists)

Once you implement the gates and declare them in `CONTROL_PLANES.yml`, **then** you should add `gate_ids` to these contract rows. At that moment, your SKIPPED semantics script will start enforcing:

* **planned/in_progress:** evidence status must be **PASS or SKIPPED** (and must exist)
* **completed:** evidence status must be **PASS**

Thatâ€™s the exact behavior your script encodes.

If you want, paste your planned gate IDs format (or the CONTROL_PLANES schema youâ€™re using) and Iâ€™ll give you the exact `gate_ids` lists to drop into these three tasks when youâ€™re ready.






Using your attached `CONTROL_PLANES.yml`, the next available **gate_id slots** are:

* Security plane currently ends at **SEC-G10**
* Integrity plane currently ends at **INT-G20**

So the **exact gate_ids to drop into the three tasks** (assuming you add the corresponding gates to `CONTROL_PLANES.yml`) are:

### TSK-P0-093 (Expand/Contract guardrails lint)

```yaml
gate_ids:
  - SEC-G11
```

### TSK-P0-094 (PK/FK type stability lint)

```yaml
gate_ids:
  - SEC-G12
```

### TSK-P0-095 (Table conventions verifier)

```yaml
gate_ids:
  - INT-G21
```

---

## Required matching additions to `CONTROL_PLANES.yml` (so these gate_ids are real)

Add these **exact** new gates:

### Under `control_planes.security.required_gates:` (append after SEC-G10)

```yaml
      - gate_id: SEC-G11
        script: scripts/security/lint_expand_contract_guardrails.sh
        evidence: evidence/phase0/migration_expand_contract_guardrails.json
      - gate_id: SEC-G12
        script: scripts/security/lint_pk_fk_type_stability.sh
        evidence: evidence/phase0/migration_pk_fk_type_stability.json
```

### Under `control_planes.integrity.required_gates:` (append after INT-G20)

```yaml
      - gate_id: INT-G21
        script: scripts/db/verify_table_conventions.sh
        evidence: evidence/phase0/table_conventions.json
```

---

## Important: this must match SKIPPED enforcement exactly

Once you add `gate_ids` to those tasks, your `verify_phase0_contract_evidence_status.sh` will start enforcing that:

* **planned / in_progress** tasks must emit evidence with `status: PASS|SKIPPED`
* **completed** tasks must emit evidence with `status: PASS`

So make sure the **contract evidence_paths** for those tasks are **exactly**:

* `evidence/phase0/migration_expand_contract_guardrails.json`
* `evidence/phase0/migration_pk_fk_type_stability.json`
* `evidence/phase0/table_conventions.json`

(Those paths already match the `CONTROL_PLANES.yml` additions above.)
