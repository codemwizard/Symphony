There is a confusion with my team. I expressly stated that I want user imbedded in the architecture right now. It is a vital and necessary part of the plans for the money transfer and NGO-based close-loop community projects. It has already been implemented buy this must be residual documentation from the time we were discussing it.
My question is why do you want it to be pushed back when it is an architectural implementation that leaves off of the invariants in place?

I’m not “against user” as a concept. I was pushing it back only because in many systems “user” ends up being a second trust model (human sessions, OAuth/OIDC, browser/mobile clients, refresh tokens, step-up auth, device binding, etc.). If you introduce that implicitly (or half-implemented) it can punch holes straight through Phase-7R invariants.

If you’re explicitly saying:

User is required now

User support is already implemented

And you still want Phase-7R/7B invariants to hold

…then the right move is not “remove user.” The right move is: make user unambiguous and invariant-preserving.

Below is the reasoning, and the exact conditions under which “user now” is safe.

Why I previously recommended pushing it back (the real risk)

“user” becomes dangerous when it is treated as equivalent to “participant/system” without:

Cryptographic verification that binds the identity to the right trust tier

e.g., placeholder JWT verification, weak claim binding, no issuer/audience enforcement

Clear authorization semantics

“user” often implies end-user privileges; “participant/system” implies institutional privileges

if you don’t separate capability scopes, you get privilege confusion

Replay + freshness controls

user tokens are replayable by default unless you enforce iat/exp, nonce/jti, max age, etc.

Request context isolation

“user” plus global RequestContext = cross-request identity bleed = broken access control

So the “pushback” was a defensive move against implicit “user” support.

When “user now” is absolutely compatible with Phase-7R invariants

If you define “user” as a first-class subject type with strict semantics, it can strengthen the architecture.

Keep Phase-7R invariants intact by enforcing these invariants for subjectType=user
Invariant A — No Ingress → No Execution (Attestation)

A user-originated request must still:

pass ingress attestation middleware before any execution

be hash-chained like everything else

✅ No conflict. User identity is orthogonal to attestation.

Invariant B — Atomic Dispatch (ledger + outbox)

Whether the caller is user or participant/system:

the ledger mutation and outbox row are still written in one DB transaction

✅ No conflict. Caller identity affects authorization not the atomic write boundary.

Invariant C — Idempotency + Retry safety

User flows often increase retries (mobile networks), so you must ensure:

user-initiated transfer requests carry an idempotency key / txId

duplicates are rejected deterministically

✅ User actually makes idempotency more important, not less.

Invariant D — Policy consistency

User tokens must be checked against:

active policy state (in-memory cached state in runtime)

or policy commit pin (PaC) for CI/evidence—different concern

✅ No conflict, but user is where policy/version enforcement matters most.

The only thing you must NOT do: “user” as a synonym for “participant”

This is where teams get into trouble.

If user is vital for closed-loop NGO/community flows, the clean model is:

Two trust tiers, one execution engine

Participant/System: institutional callers (mTLS, cert-bound identity)

User: human actor operating under a participant tenancy (OIDC/JWT, device-bound, etc.)

Key rule: every user must be anchored to a participant tenancy:

participant_id is mandatory on user identity

authorization checks must validate user actions are within that participant’s scope

That avoids “a user becomes a global super-user.”

What “unambiguous user” looks like (practical spec)

If you want user embedded now, I’d align the team on this contract:

1) Identity envelope must bind these fields for user

Minimum required claims for subjectType=user:

subject_type: "user"

subject_id (user id)

participant_id (tenant anchor — required)

trust_tier: "user"

issuer, audience

iat, exp (and enforce max token age)

jti (optional but recommended for replay controls)

policy_version or policy_commit depending on your runtime model

capabilities (or roles that map to capabilities)

2) Verification must be real, not placeholder

For user JWT verification:

verify signature (ES256 is a solid pick)

validate iss/aud/exp/iat

enforce max token age (e.g., 5 minutes) to limit replay window

bind additional fields into signature-critical claims:

participant_id, trust_tier, policy_version/commit, key fingerprint (where applicable)

3) Authorization must be explicit

requireCapability() must:

treat user capabilities as a subset of participant/system capabilities

enforce tenant boundary: claims.participant_id must match target resources

4) Observability/evidence must include “who did what”

Ingress attestation should record:

subject type

subject id hash (or redacted form)

participant id

capability decision outcome
…without leaking secrets

This helps regulators later, and it helps you debug.

Why this “builds off invariants” rather than breaking them

Because the invariants you care about (attestation-first, atomic outbox, monotonic ids, zombie repair bounds) are execution safety invariants.

“user” is an identity + authorization surface.

As long as user is:

cryptographically verified

tenant-anchored

capability-scoped

request-context isolated (ALS)
…it does not weaken execution invariants; it just controls who is allowed to trigger them.

The real reason teams get confused

A lot of architectures accidentally do:

Participant = institution

User = “someone”

And then they reuse the same authorization pathway without strict separation

That’s where audits flag “ambiguous subject type support.”

So the correction is not “remove user.” It’s “stop letting user be ambiguous.”

Bottom line

I only wanted to push it back if “user” was implicit / underspecified / placeholder-verified.
If “user” is a first-class, tenant-anchored, cryptographically verified subject type, then it’s absolutely a Phase-7B-safe implementation and it improves the robustness story.

If you want, I can write a one-page “User SubjectType Contract” you can drop into your docs that:

defines required claims

defines verification steps

defines allowed capabilities

and lists the exact invariants that must still hold (Phase-7R carryover)

That usually ends the team debate fast because it turns “user” into a crisp spec instead of a vibe.

Write the one-pager "User SubjectType Contract"
User SubjectType Contract (Symphony / Phase-7R+)

Status: Required (Phase-7R/7B)
Applies to: All request execution paths that accept subjectType = "user"
Goal: Embed user flows now without weakening the Phase-7R invariants (attestation-first, atomic dispatch, idempotency, policy lock integrity, and request-context isolation).

1) Definition & Intent
1.1 SubjectType: user

A user is a human actor initiating actions within a participant tenancy, and must never be treated as an unscoped global principal.

Core rule:
A user identity is valid only when it is tenant-anchored to a participant_id and is cryptographically verified.

1.2 Non-goals

This contract does not define PMaaS runtime policy distribution, sidecar enforcement, ingress attestation infrastructure, or database seed truth. This is PaC identity correctness for build + runtime verification logic.

2) Trust Model & Separation
2.1 Trust tiers

Two trust tiers exist and must remain distinct:

participant/system

Institutional actor (service identity, mTLS, signed service tokens)

Can trigger privileged operational flows

user

Human actor (JWT/OIDC-like)

Must be capability-scoped and tenant-anchored

2.2 Forbidden equivalence

It is forbidden to interpret:

subjectType=user as equivalent to participant/system

a missing subjectType as user

a missing participant_id as “inferable”

If any required field is missing: fail closed.

3) Required Identity Claims (User)

A request is considered “user-authenticated” only if the identity envelope contains the following required claims.

3.1 Required fields (minimum)
Field	Type	Requirement
subjectType	string	MUST equal "user"
subjectId	string	MUST be present, non-empty
participantId	string	MUST be present, non-empty (tenant anchor)
trustTier	string	MUST equal "user"
issuer (iss)	string	MUST be present and allowlisted
audience (aud)	string	MUST match service audience
issuedAt (iat)	number	MUST be present
expiresAt (exp)	number	MUST be present
capabilities OR roles	array	MUST be present (non-empty)
policyCommit OR policyVersion	string	MUST be present (see §6)
3.2 Optional but recommended
Field	Type	Use
jti	string	Replay protection / traceability
deviceId	string	Device binding for mobile flows
sessionId	string	Session scoping + auditing
authContext	object	Step-up / MFA / risk signals
4) Cryptographic Verification (Fail Closed)
4.1 Verification requirements

A user identity MUST be cryptographically verified before any execution logic:

Verify JWT signature using a pinned or fetched JWKS (allowlisted issuer)

Validate iss, aud

Validate exp (not expired)

Validate iat (not in the future beyond skew)

Enforce max token age (recommended ≤ 5 minutes for high-risk actions)

Validate required fields exist and match allowed formats

If any check fails → request MUST be rejected.

4.2 Clock skew

Allow a small skew (e.g., 60 seconds). Anything larger is a misconfiguration and should fail.

5) Authorization Rules (Capabilities & Tenant Anchor)
5.1 Tenant boundary is mandatory

For any operation that touches tenant-scoped resources:

claims.participantId MUST equal the resource tenant

No cross-tenant access is permitted unless explicitly defined as an administrative capability and audited

5.2 Capability-driven authorization

User authorization MUST be evaluated via explicit capability checks.

Examples:

TRANSFER_CREATE

TRANSFER_APPROVE

BENEFICIARY_ADD

LEDGER_VIEW

LEDGER_EXPORT

Roles are allowed only if they map deterministically to capabilities.
Do not implement “role strings” with ad-hoc logic.

5.3 Least privilege baseline

User capabilities MUST be strictly narrower than participant/system capabilities.

6) Policy Binding (PaC Compatibility)
6.1 Policy source of truth

For PaC, the policy repository pinned by `.policy

Is this accurate and answer my guidance questions at the bottom:
User Identity: Role, Capabilities, and Limitations
Role
A user is a human actor operating under a participant tenancy. Users are NOT institutional actors (those are participant or service). Users trigger actions but are always scoped and verified.

Capabilities (Permitted)
Trigger tenant-scoped financial flows (e.g., TRANSFER_CREATE, TRANSFER_APPROVE)
View their tenant's ledger data
Perform actions within their participantId boundary
User capabilities are a strict subset of participant/system capabilities
Limitations (Non-Negotiable)
Limitation	Description
Tenant Anchoring	participantId is MANDATORY. A user without a participant anchor is invalid.
Trust Tier Separation	trustTier for users must be "user" or "external". Cannot escalate to "internal".
No Cross-Tenant Access	claims.participantId MUST match the target resource's tenant. No global access.
Cryptographic Verification	JWT signature (ES256 or similar), iss, aud, exp, iat MUST be validated.
Token Freshness	Max token age enforced (≤5 minutes recommended). Expired tokens rejected.
Not a Participant Synonym	Users cannot exercise participant-level or system-level capabilities.
Current Implementation Gaps
Based on my code review of 
verifyIdentity.ts
, 
identity.ts
, and 
schema.ts
:

Gap	Location	Status
participantId is optional	
schema.ts
 line 26, 
identity.ts
 line 26	NOT ENFORCED for user
User verification logic is empty	
verifyIdentity.ts
 lines 89-94	PLACEHOLDER (no real check)
Issuer allowlist for user tokens	
verifyIdentity.ts
NOT IMPLEMENTED
Trust tier enforcement for user	
verifyIdentity.ts
NOT IMPLEMENTED
Where I Need Guidance
Issuer Allowlist: What specific issuers (e.g., auth0, cognito, symphony-auth) should be allowlisted for subjectType='user' tokens?
User Trust Tier Value: Should users have trustTier: 'user' (new enum value) or trustTier: 'external' (existing)?
JWKS/Key Verification: Should we implement full JWKS fetching for user JWTs, or use a pre-shared signing key similar to HMAC for services? (Full JWKS is more standard for OIDC flows.)

Yes — this is accurate in intent and it does answer the architectural direction you’ve set (“users are first-class, tenant-anchored humans”), but a couple of terms should be tightened so the contract is unambiguous and hard to misinterpret.

What’s accurate

User = human actor under participant tenancy (correct and necessary for closed-loop/NGO flows).

Strict tenant anchoring (participantId mandatory) is the right invariant.

No cross-tenant rule is essential and correctly stated.

Crypto verification + freshness is correct and aligns with Phase-7R posture.

Users are not participants/system is correctly explicit.

What I would tighten (small but important)

Trust tier wording

Saying trustTier must be "user" or "external" introduces ambiguity (“external” can mean many things).

Make it one canonical value for users, and treat “external” as a source attribute, not a tier.

Capabilities vs limitations

“View their tenant’s ledger data” is fine, but add: only via read models / filtered views; never raw tables unless read API is explicitly scoped.

“ES256 or similar”

Replace with “ES256 required” (or whichever you choose) to avoid drift.

Guidance answers (your three questions)
1) Issuer allowlist: which issuers?

Use an allowlist by environment + audience, not a single global list.

Recommended baseline:

Primary: symphony-auth (your own issuer, even if it is a thin wrapper over an upstream IdP)

Optional (only if you already run them): https://<your-auth0-tenant>/ or https://cognito-idp.<region>.amazonaws.com/<pool_id>

Rule of thumb: Allowlist issuers you can operationally control and rotate without “surprise” breaking changes. If you expect multiple community operators, put them behind symphony-auth so Symphony only trusts one issuer.

2) User trustTier value: 'user' or 'external'?

Use trustTier: "user" (new enum value).

Reason: external is a provenance concept (where the identity came from), not a privilege boundary. Your privilege boundary is:

system / participant (institutional)

user (human)

If you need to express provenance, add a separate field like:

identitySource: "oidc" | "mtls" | "internal-service", or

authMethod: "jwt" | "mtls"

3) JWKS fetching vs pre-shared signing key (HMAC)

For user tokens, do ES256 + JWKS (pinned).

Minimum viable, low-pain option (recommended now):

Keep a static JWKS file in repo (or in a config bucket) for sandbox/staging.

In production, switch to JWKS URL (OIDC well-known) with caching.

Avoid HMAC for users unless you are 100% sure you will never federate external IdPs. HMAC makes multi-issuer governance messy and increases blast radius (shared secret leakage).

One small correction to your “Implementation Gaps” section

Your gaps are plausible, but the line numbers might drift; the key is the requirements:

participantId must be required when subjectType=user

verifyIdentity must actually validate: iss/aud/exp/iat/jti(optional)/policyCommit

trustTier must be checked and must not be user-controllable escalation

Suggested “final wording” you can drop into your doc

Issuer allowlist: “Allowed issuers are environment-scoped and pinned. Default allowed issuer is symphony-auth. Additional issuers require explicit allowlist entry plus audience binding.”

Trust tier: “trustTier=user is required for subjectType=user. external is not a tier; provenance is represented via identitySource.”

Key verification: “User JWTs MUST be verified with ES256 against JWKS. In sandbox, JWKS may be pinned as a static file. In production, JWKS may be fetched from a well-known endpoint with caching and fail-closed semantics.”

If you paste your current verifyIdentity.ts and schema.ts (or the relevant excerpts), I can translate this contract into exact enforcement rules and a minimal patch list without expanding scope.

## verifyIdentity.ts

import { IdentityEnvelopeV1, ValidatedIdentityContext } from "./identity.js";
import { validatePolicyVersion } from "../db/policy.js";
import { TrustFabric } from "../auth/trustFabric.js";
import crypto from "crypto";
import { KeyManager } from "../crypto/keyManager.js";

// OU Interaction Graph (Phase 3)
// Allowed issuers for each service/OU
const ALLOWED_ISSUERS: Record<string, string[]> = {
    'control-plane': ['client', 'ingest-api'], // OU-01/OU-03 accepts from Client or Ingest
    'ingest-api': ['client'],                // OU-04 accepts from Client
    'executor-worker': ['control-plane'],     // OU-05 accepts from Control Plane (OU-03)
    'read-api': ['executor-worker'],          // OU-06 accepts from Executor (OU-05)
};

// SEC-7R-FIX: Clock skew tolerance and max token age
const CLOCK_SKEW_MS = 30_000; // 30 seconds
const MAX_TOKEN_AGE_MS = 5 * 60 * 1000; // 5 minutes

/**
 * Verifies the identity envelope and returns a validated, immutable context.
 * Throws on any violation (Fail-Closed).
 * 
 * SEC-7R-FIX: Implements timing-safe comparison, canonical JSON, and freshness checks.
 */
export async function verifyIdentity(
    envelope: IdentityEnvelopeV1,
    currentService: string,
    keyManager: KeyManager, // Dependency Injection (INV-SEC-04)
    certFingerprint?: string // Phase 6.4: Optional for clients, mandatory for services
): Promise<ValidatedIdentityContext> {

    // 1. Basic Schema & Version Validation
    if (envelope.version !== 'v1') throw new Error("Unsupported identity version");

    // SEC-7R-FIX: Token freshness check with clock skew tolerance
    const issuedAt = new Date(envelope.issuedAt).getTime();
    const now = Date.now();
    if (isNaN(issuedAt)) {
        throw new Error("Invalid issuedAt timestamp");
    }
    if (now - issuedAt > MAX_TOKEN_AGE_MS + CLOCK_SKEW_MS) {
        throw new Error("Identity token too old - re-authentication required");
    }
    if (issuedAt > now + CLOCK_SKEW_MS) {
        throw new Error("Identity token issued in the future");
    }

    // 2. SEC-7R-FIX: Canonical JSON with sorted keys for deterministic signatures
    // Includes trustTier and certFingerprint for complete binding
    const dataToSign = JSON.stringify({
        certFingerprint: envelope.certFingerprint ?? null,
        issuedAt: envelope.issuedAt,
        issuerService: envelope.issuerService,
        policyVersion: envelope.policyVersion,
        requestId: envelope.requestId,
        roles: envelope.roles.slice().sort(), // Sorted for determinism
        subjectId: envelope.subjectId,
        subjectType: envelope.subjectType,
        tenantId: envelope.tenantId,
        trustTier: envelope.trustTier ?? null,
        version: envelope.version,
    });

    const expectedSignature = crypto
        .createHmac('sha256', await keyManager.deriveKey('identity/hmac'))
        .update(dataToSign)
        .digest('hex');

    // SEC-7R-FIX: Timing-safe comparison to prevent timing attacks
    const sigBuffer = Buffer.from(envelope.signature, 'hex');
    const expectedBuffer = Buffer.from(expectedSignature, 'hex');

    if (sigBuffer.length !== expectedBuffer.length ||
        !crypto.timingSafeEqual(sigBuffer, expectedBuffer)) {
        throw new Error("Invalid identity signature");
    }

    // 3. Policy Version Validation
    // SEC-7R-FIX: Enforce active policy version matching.
    await validatePolicyVersion(envelope.policyVersion);

    // 4. Directional Trust Enforcement (OU Interaction Graph)
    const allowed = ALLOWED_ISSUERS[currentService];
    if (!allowed || !allowed.includes(envelope.issuerService)) {
        // Special case for initial client requests
        if (envelope.subjectType === 'client' && allowed && allowed.includes('client')) {
            // Allowed
        } else if (envelope.subjectType === 'user') {
            // Finding #5: 'user' subject type supported in Phase 7B
            // User identity must be validated against allowed issuers (e.g. client)
        } else {
            throw new Error(Unauthorized OU interaction: ${envelope.issuerService} -> ${currentService});
        }
    }



    // 5. Phase 6.4: mTLS & Trust Fabric Enforcement
    if (envelope.subjectType === 'service') {
        if (!certFingerprint) {
            throw new Error("mTLS Violation: Service-to-service calls require cryptographic proof.");
        }

        const identity = TrustFabric.resolveIdentity(certFingerprint);
        if (!identity) {
            throw new Error("mTLS Violation: Revoked or untrusted certificate.");
        }

        // Bind mTLS claim to envelope subject
        if (identity.serviceName !== envelope.issuerService) {
            throw new Error(mTLS Violation: Certificate identity (${identity.serviceName}) mismatch with claim (${envelope.issuerService}).);
        }

        // Ensure OU consistency
        // In a real system, envelope.ou would be checked here if present.
    }

    // 6. Freeze and Return
    return Object.freeze({
        ...envelope,
        ...(certFingerprint ? { certFingerprint } : {})
    });
}


## schema.ts

/**
 * Symphony Canonical Audit Schema — v1
 * Phase Key: SYM-33
 * 
 * Objectives:
 * - Immutability
 * - Non-repudiation
 * - Regulator-grade forensics
 */

export type AuditEventType =
    | 'IDENTITY_VERIFY'
    | 'AUTHZ_ALLOW'
    | 'AUTHZ_DENY'
    | 'INSTRUCTION_SUBMIT'
    | 'INSTRUCTION_CANCEL'
    | 'EXECUTION_ATTEMPT'
    | 'EXECUTION_ABORT'
    | 'POLICY_ACTIVATE'
    | 'KILLSWITCH_ENGAGE'
    | 'EVIDENCE_EXPORT'
    | 'INCIDENT_SIGNAL'
    | 'CONTAINMENT_ACTIVATE'
    // Phase 7.1: Participant Identity & Guard Events
    | 'PARTICIPANT_RESOLVED'
    | 'PARTICIPANT_RESOLUTION_FAILED'
    | 'PARTICIPANT_STATUS_DENY'
    | 'GUARD_IDENTITY_DENY'
    | 'GUARD_AUTHORIZATION_DENY'
    | 'GUARD_POLICY_DENY'
    | 'GUARD_LEDGER_SCOPE_DENY'
    // Phase 7.2: Execution, Retry & Repair Events
    | 'EXECUTION_ATTEMPT_CREATED'
    | 'EXECUTION_ATTEMPT_SENT'
    | 'EXECUTION_ATTEMPT_RESOLVED'
    | 'RETRY_EVALUATED'
    | 'RETRY_ALLOWED'
    | 'RETRY_BLOCKED'
    | 'REPAIR_INITIATED'
    | 'REPAIR_RECONCILIATION_RESULT_RECORDED'
    | 'REPAIR_COMPLETED';

export interface AuditRecordV1 {
    eventId: string;        // UUID
    eventType: AuditEventType;
    timestamp: string;      // ISO-8601
    requestId: string;
    tenantId: string;
    subject: {
        type: 'client' | 'service';
        id: string;           // subjectId
        ou: string;           // issuerService / currentService
        certFingerprint?: string; // Phase 6.4: mTLS proof
    };
    action: {
        capability?: string;
        resource?: string;    // instructionId, providerId, etc.
    };
    decision: 'ALLOW' | 'DENY' | 'EXECUTED';
    policyVersion: string;
    reason?: string;
    integrity: {
        prevHash: string;     // Hash of the immediately preceding record
        hash: string;         // SHA-256(this_record_serialized || prevHash)
    };
}

Got it. Two big takeaways from what you pasted:

verifyIdentity.ts already supports “user” as an envelope subjectType, but the enforcement is currently incomplete/ambiguous (it “mentions” user, but doesn’t constrain it).

Your audit schema currently cannot represent user identities at all, because subject.type is only 'client' | 'service'. That will cause “residual documentation / confusion” forever, because your audit layer contradicts your runtime intent.

Below is the minimal, Phase-7B-appropriate patch set that makes user unambiguous, tenant-anchored, and non-escalatory—without requiring you to swap the whole identity envelope to JWT immediately.

1) Clarify the model: User tokens vs Symphony IdentityEnvelope

Right now, verifyIdentity() verifies an internal Symphony identity envelope (HMAC signature using KeyManager). That implies:

User JWT verification happens before this (at ingress / edge / gateway), and

Symphony then mints an IdentityEnvelopeV1 for downstream internal services.

That is totally fine for Phase-7B.

Contract you should enforce now (unambiguous):

subjectType="user" means: human actor.

User requests enter at ingress, get verified (JWT etc.), then are wrapped into a signed Symphony envelope.

Internal services trust the envelope signature and enforce scope; they do not accept raw user JWTs.

This is the “cleanest” way to keep your OU graph and mTLS story intact.

2) Required changes in verifyIdentity.ts (minimal, fail-closed)
A. Add explicit User Contract checks (tenant anchor + tier + issuer path)

Right after policy validation (after step 3) is a good place.

Rules:

tenantId MUST be present and non-empty for subjectType === 'user' (this is your participant anchor).

trustTier MUST equal "user" (do not allow "internal" or "external" ambiguity).

certFingerprint MUST be absent for user envelopes (or ignored) to avoid fake “mTLS privilege”.

issuerService MUST be in a user-issuer allowlist (ex: client and/or ingest-api) depending on your architecture.

OU interaction graph must treat user as not a service: users should only be accepted at entry surfaces (typically ingest-api, maybe control-plane).

B. Make OU enforcement deterministic for user

Right now you have:

} else if (envelope.subjectType === 'user') {
  // ... comment
} else {
  throw ...
}


That comment block needs to become an actual rule.

Here’s the exact drop-in patch pattern:

// after await validatePolicyVersion(...)

if (envelope.subjectType === "user") {
  // Tenant anchoring (your invariant)
  if (!envelope.tenantId || envelope.tenantId.trim().length === 0) {
    throw new Error("User identity invalid: tenantId (participant anchor) is required");
  }

  // Trust-tier: single canonical value
  if (envelope.trustTier !== "user") {
    throw new Error(`User identity invalid: trustTier must be "user" (got ${String(envelope.trustTier)})`);
  }

  // Users are not mTLS principals
  if (certFingerprint) {
    throw new Error("User identity invalid: user requests must not present mTLS service proof");
  }

  // User issuer constraint (who is allowed to mint/forward user envelopes)
  // Choose ONE of these approaches:
  // 1) Only the edge/ingest layer can present user envelopes:
  const USER_ALLOWED_ISSUERS = ["client", "ingest-api"];
  if (!USER_ALLOWED_ISSUERS.includes(envelope.issuerService)) {
    throw new Error(`User identity invalid: issuerService ${envelope.issuerService} not allowed for user`);
  }

  // AND: user envelopes only accepted by entry services
  const USER_ACCEPTING_SERVICES = ["ingest-api", "control-plane"]; // tighten to just ingest-api if possible
  if (!USER_ACCEPTING_SERVICES.includes(currentService)) {
    throw new Error(`User identity invalid: user identity cannot call ${currentService} directly`);
  }
}


Then your OU graph check can remain for non-user subjects.

C. Optional but recommended: bind issuer path for user envelopes

If you want zero ambiguity, add a field later like authMethod: "jwt" and/or identitySource, but that’s Phase-7R/8 polish—not required to unblock correctness.

3) Required changes in schema.ts (your audit contract is currently wrong)

Your audit schema must be able to represent a user, otherwise the architecture will always look “unsupported”.

A. Expand subject type union

Change:

type: 'client' | 'service';


to:

type: 'client' | 'service' | 'user';

B. Enforce tenant anchoring at the audit level

You already have tenantId at the record top-level (good). For user traceability, consider also adding participant anchor explicitly in the subject block (optional but clarity improves):

subject: {
  type: 'client' | 'service' | 'user';
  id: string;
  ou: string;
  tenantId?: string; // optional duplication for audit readability (record already has tenantId)
  certFingerprint?: string;
};


If you keep it only at record level, that’s okay—but don’t lose it.

C. Prevent “user = service” confusion in audit

Keep certFingerprint meaningful:

present for subject.type === 'service'

absent for user/client

This matches the contract you’re enforcing in verifyIdentity().

4) One subtle issue: your signature canonicalization isn’t fully canonical

You wrote “sorted keys” but you’re relying on JSON.stringify({ ...literal... }) order.

In modern Node, object literal insertion order is stable, so this is OK operationally as long as both signer and verifier use the exact same structure. But it’s not “true canonical JSON” in a cryptographic spec sense.

Phase-7B practical fix (minimal):

Keep what you have, but rename the comment to “deterministic serialization” not “canonical JSON”.

If you want real canonical JSON later, introduce a canonicalizer function (Phase-8).

5) Why pushing “user” back would be wrong here

Because your invariants already assume:

tenant/participant anchoring

scoped capabilities

explicit trust-tier separation

“User” is not a relaxation; it’s an explicit actor type. The risk is not the existence of users—it's allowing “user” to be underspecified (optional tenantId, ambiguous trustTier, issuer path undefined). Your patch should remove that ambiguity, not remove the user type.

6) What I need you to decide (one decision, not a long back-and-forth)

Pick ONE:

Option A (recommended): user envelopes only accepted by ingest-api (and maybe control-plane if you truly need it)

Option B: user envelopes can be accepted by multiple services (harder to reason about; I don’t recommend unless you have a strong reason)

If you say “Option A”, I’ll give you the final exact ALLOWED_ISSUERS + USER_ACCEPTING_SERVICES tables that align with your OU graph.

If you don’t want to decide, default to Option A—it’s the safest and most compliant.

Option A

Option A locked in ✅ — user identities are only accepted at the entry surface (ingest-api).

Below is the exact enforcement table + the minimal code patches to make “user” unambiguous and fail-closed, while keeping your existing OU graph + invariants intact.

1) Policy tables for Option A
User envelope acceptance (hard boundary)

User identities are only valid at: ingest-api

User identity issuer allowed to present at ingest-api: client (only)

That means:

subjectType	currentService	allowed issuerService
user	ingest-api	client

This is the cleanest “entry-only” posture and aligns with your OU graph intent.

2) Patch: verifyIdentity.ts (make user enforcement real)
Add these constants near the top (next to ALLOWED_ISSUERS)
// Option A (Phase-7B): user identities are entry-surface only
const USER_ACCEPTING_SERVICES = ['ingest-api'] as const;
const USER_ALLOWED_ISSUERS = ['client'] as const;

// Canonical trust-tier value for user identities (prevents ambiguity)
const USER_TRUST_TIER = 'user' as const;

Add this fail-closed user contract block right after policy validation:

Put it immediately after:

await validatePolicyVersion(envelope.policyVersion);


Add:

// 3.5 User SubjectType Contract (Option A: entry-only)
// Users must be tenant-anchored and never treated as mTLS principals.
if (envelope.subjectType === 'user') {
    // Entry surface only
    if (!USER_ACCEPTING_SERVICES.includes(currentService as any)) {
        throw new Error(`User identity invalid: user identities may only be accepted by ${USER_ACCEPTING_SERVICES.join(', ')}`);
    }

    // Allowed issuer path (who is allowed to present a user envelope to ingest-api)
    if (!USER_ALLOWED_ISSUERS.includes(envelope.issuerService as any)) {
        throw new Error(`User identity invalid: issuerService ${envelope.issuerService} not allowed for user`);
    }

    // Tenant anchoring (participant tenancy invariant)
    if (!envelope.tenantId || envelope.tenantId.trim().length === 0) {
        throw new Error('User identity invalid: tenantId (participant anchor) is required');
    }

    // Trust-tier separation (no escalation)
    if (envelope.trustTier !== USER_TRUST_TIER) {
        throw new Error(`User identity invalid: trustTier must be "${USER_TRUST_TIER}"`);
    }

    // Users are not mTLS principals (prevents privilege confusion)
    if (certFingerprint) {
        throw new Error('User identity invalid: user requests must not present service mTLS proof');
    }
}

Tighten your OU enforcement block so user doesn’t “fall through”

Replace your current “user comment block” with a hard decision:

} else if (envelope.subjectType === 'user') {
    // If we got here, user failed entry-only checks above OR is being presented to a non-entry service
    throw new Error(`Unauthorized OU interaction for user: ${envelope.issuerService} -> ${currentService}`);
}


That makes user handling deterministic (no placeholder).

3) Patch: schema.ts (audit must represent user)

Right now your audit schema contradicts your architecture.

Change:

type: 'client' | 'service';


to:

type: 'client' | 'service' | 'user';


Optionally (recommended for clarity), add an explicit tenant anchor to subject (even though AuditRecordV1 already has tenantId):

tenantId?: string; // optional duplication for readability (record already has tenantId)


And keep this invariant in code: certFingerprint should only be present when type === 'service'.

4) What this achieves (why it matches your invariants)

No widening of trust: user cannot appear anywhere except ingress.

No privilege confusion: user cannot be “service-like” (no mTLS binding, no OU traversal).

Tenant-scoped by construction: tenantId required.

Trust tier non-escalatory: must be "user".

This doesn’t “push user back” — it makes user architecturally safe.

5) One small guidance answer you asked earlier (now that Option A is chosen)

Issuer allowlist for user tokens:
For the internal envelope layer: issuerService = "client" only (because only the edge request can originate user intent).

If later you move to “ingest-api verifies JWT and mints envelope”, then you’ll switch to:

user envelope issuerService = "ingest-api" (because ingest is minting it)

and update USER_ALLOWED_ISSUERS accordingly

…but that’s a controlled, single-line change when you reach that step.

If you want, paste your current IdentityEnvelopeV1 type definition (libs/context/identity.ts) and I’ll give you the exact type-level tightening (e.g., making tenantId required when subjectType === 'user') without breaking other subject types.

/**
 * Symphony Identity Envelope (v1)
 * Cryptographically verifiable identity context
 *
 * Phase 7.1 Enhancement:
 * Added participant identity fields for regulated actor tracking.
 */

import type { ParticipantRole, ParticipantStatus } from '../participant/participant.js';

export interface IdentityEnvelopeV1 {
    version: 'v1';
    requestId: string;
    issuedAt: string;        // ISO-8601
    issuerService: string;   // e.g. 'control-plane', 'ingest-api'
    subjectType: 'client' | 'service' | 'user';
    subjectId: string;       // client_id or service_id
    tenantId: string;
    policyVersion: string;
    roles: string[];         // DB / service roles
    signature: string;       // HMAC-sha256 in v1
    trustTier: 'external' | 'internal';
    certFingerprint?: string; // Phase 6.4: mTLS proof

    // Phase 7.1: Participant Identity (Regulated Actor)
    participantId?: string;           // Resolved participant ID
    participantRole?: ParticipantRole;    // BANK, PSP, OPERATOR, SUPERVISOR
    participantStatus?: ParticipantStatus; // ACTIVE, SUSPENDED, REVOKED
}

export type ValidatedIdentityContext = Readonly<IdentityEnvelopeV1>;

Perfect — this type is exactly where we make Option A unambiguous at compile-time, not just runtime.

Right now you have two mismatches with the contract we want:

trustTier doesn’t include "user" (but Option A needs it).

tenantId is required (good), but participantId is optional (bad for “user is anchored to participant tenancy”).

Below is the cleanest “least pain” tightening that keeps compatibility and makes “user” explicit.

1) Make the envelope a discriminated union (TypeScript-enforced contract)

Replace your current IdentityEnvelopeV1 interface with this union:

import type { ParticipantRole, ParticipantStatus } from '../participant/participant.js';

type BaseEnvelopeV1 = {
  version: 'v1';
  requestId: string;
  issuedAt: string;        // ISO-8601
  issuerService: string;   // e.g. 'control-plane', 'ingest-api'
  subjectId: string;       // client_id / service_id / user_id
  tenantId: string;        // REQUIRED for all (good)
  policyVersion: string;
  roles: string[];         // capability roles
  signature: string;       // HMAC-sha256 in v1
  certFingerprint?: string; // mTLS proof (service-only at runtime)
  
  // Phase 7.1: Participant Identity (Regulated Actor)
  participantId?: string;
  participantRole?: ParticipantRole;
  participantStatus?: ParticipantStatus;
};

export type IdentityEnvelopeV1 =
  | (BaseEnvelopeV1 & {
      subjectType: 'service';
      trustTier: 'internal';
      certFingerprint: string;        // required for service envelopes
      // participantId optional; service calls may not be tied to a participant
    })
  | (BaseEnvelopeV1 & {
      subjectType: 'client';
      trustTier: 'external';
      // certFingerprint optional; client requests may not have mTLS
      // participantId optional; client may be pre-resolution
    })
  | (BaseEnvelopeV1 & {
      subjectType: 'user';
      trustTier: 'external' | 'user'; // allow 'user' if you want it, but see note below
      participantId: string;          // REQUIRED for users (tenant anchoring invariant)
      // certFingerprint must be absent/ignored at runtime (enforced in verifyIdentity)
    });

export type ValidatedIdentityContext = Readonly<IdentityEnvelopeV1>;

Why this is “Option A” correct

User must have participantId (compile-time enforced).

Service must have certFingerprint (compile-time enforced).

Still allows existing client flows without forcing participant resolution immediately.

2) Trust tier: pick one value and freeze it

You said “Option A”. For less confusion, I recommend:

User trustTier = "external" (and drop "user" entirely)

Because trustTier is about the trust boundary, not the subject type. “user” is already a subjectType.

So the tightest version is:

trustTier: 'external' | 'internal';


and for user branch:

trustTier: 'external';


If you keep "user" as a trustTier, you’ll end up maintaining two taxonomies forever (subjectType and trustTier) that overlap.

Recommendation (strong):

Keep trustTier as 'external' | 'internal'

User => 'external'

Service => 'internal'

3) Minimum runtime check updates you must keep

Even with the typing, keep these runtime invariants in verifyIdentity.ts:

If subjectType === 'user', reject if currentService !== 'ingest-api'

If subjectType === 'user', require issuerService in ['client']

If subjectType === 'user', require participantId (now redundant but good defense)

If subjectType === 'service', require certFingerprint AND TrustFabric match

This combination gives you: compile-time contract + fail-closed runtime enforcement.

4) Quick note on your earlier “User SubjectType Contract”

With this typing, your contract becomes mechanically true:

user is always tenant-anchored (tenantId + participantId)

user is never service (certFingerprint not required/expected)

user cannot propagate beyond ingress (runtime gate)

If you paste your verifyIdentity.ts current “user” section (the part that’s still a placeholder), I’ll rewrite it as a single crisp block that matches this union exactly and can’t be accidentally bypassed.

import { IdentityEnvelopeV1, ValidatedIdentityContext } from "./identity.js";
import { validatePolicyVersion } from "../db/policy.js";
import { TrustFabric } from "../auth/trustFabric.js";
import crypto from "crypto";
import { KeyManager } from "../crypto/keyManager.js";

// OU Interaction Graph (Phase 3)
// Allowed issuers for each service/OU
const ALLOWED_ISSUERS: Record<string, string[]> = {
    'control-plane': ['client', 'ingest-api'], // OU-01/OU-03 accepts from Client or Ingest
    'ingest-api': ['client'],                // OU-04 accepts from Client
    'executor-worker': ['control-plane'],     // OU-05 accepts from Control Plane (OU-03)
    'read-api': ['executor-worker'],          // OU-06 accepts from Executor (OU-05)
};

// SEC-7R-FIX: Clock skew tolerance and max token age
const CLOCK_SKEW_MS = 30_000; // 30 seconds
const MAX_TOKEN_AGE_MS = 5 * 60 * 1000; // 5 minutes

/**
 * Verifies the identity envelope and returns a validated, immutable context.
 * Throws on any violation (Fail-Closed).
 * 
 * SEC-7R-FIX: Implements timing-safe comparison, canonical JSON, and freshness checks.
 */
export async function verifyIdentity(
    envelope: IdentityEnvelopeV1,
    currentService: string,
    keyManager: KeyManager, // Dependency Injection (INV-SEC-04)
    certFingerprint?: string // Phase 6.4: Optional for clients, mandatory for services
): Promise<ValidatedIdentityContext> {

    // 1. Basic Schema & Version Validation
    if (envelope.version !== 'v1') throw new Error("Unsupported identity version");

    // SEC-7R-FIX: Token freshness check with clock skew tolerance
    const issuedAt = new Date(envelope.issuedAt).getTime();
    const now = Date.now();
    if (isNaN(issuedAt)) {
        throw new Error("Invalid issuedAt timestamp");
    }
    if (now - issuedAt > MAX_TOKEN_AGE_MS + CLOCK_SKEW_MS) {
        throw new Error("Identity token too old - re-authentication required");
    }
    if (issuedAt > now + CLOCK_SKEW_MS) {
        throw new Error("Identity token issued in the future");
    }

    // 2. SEC-7R-FIX: Canonical JSON with sorted keys for deterministic signatures
    // Includes trustTier and certFingerprint for complete binding
    const dataToSign = JSON.stringify({
        certFingerprint: envelope.certFingerprint ?? null,
        issuedAt: envelope.issuedAt,
        issuerService: envelope.issuerService,
        policyVersion: envelope.policyVersion,
        requestId: envelope.requestId,
        roles: envelope.roles.slice().sort(), // Sorted for determinism
        subjectId: envelope.subjectId,
        subjectType: envelope.subjectType,
        tenantId: envelope.tenantId,
        trustTier: envelope.trustTier ?? null,
        version: envelope.version,
    });

    const expectedSignature = crypto
        .createHmac('sha256', await keyManager.deriveKey('identity/hmac'))
        .update(dataToSign)
        .digest('hex');

    // SEC-7R-FIX: Timing-safe comparison to prevent timing attacks
    const sigBuffer = Buffer.from(envelope.signature, 'hex');
    const expectedBuffer = Buffer.from(expectedSignature, 'hex');

    if (sigBuffer.length !== expectedBuffer.length ||
        !crypto.timingSafeEqual(sigBuffer, expectedBuffer)) {
        throw new Error("Invalid identity signature");
    }

    // 3. Policy Version Validation
    // SEC-7R-FIX: Enforce active policy version matching.
    await validatePolicyVersion(envelope.policyVersion);

    // 4. Directional Trust Enforcement (OU Interaction Graph)
    const allowed = ALLOWED_ISSUERS[currentService];
    if (!allowed || !allowed.includes(envelope.issuerService)) {
        // Special case for initial client requests
        if (envelope.subjectType === 'client' && allowed && allowed.includes('client')) {
            // Allowed
        } else if (envelope.subjectType === 'user') {
            // Finding #5: 'user' subject type supported in Phase 7B
            // User identity must be validated against allowed issuers (e.g. client)
        } else {
            throw new Error(Unauthorized OU interaction: ${envelope.issuerService} -> ${currentService});
        }
    }



    // 5. Phase 6.4: mTLS & Trust Fabric Enforcement
    if (envelope.subjectType === 'service') {
        if (!certFingerprint) {
            throw new Error("mTLS Violation: Service-to-service calls require cryptographic proof.");
        }

        const identity = TrustFabric.resolveIdentity(certFingerprint);
        if (!identity) {
            throw new Error("mTLS Violation: Revoked or untrusted certificate.");
        }

        // Bind mTLS claim to envelope subject
        if (identity.serviceName !== envelope.issuerService) {
            throw new Error(mTLS Violation: Certificate identity (${identity.serviceName}) mismatch with claim (${envelope.issuerService}).);
        }

        // Ensure OU consistency
        // In a real system, envelope.ou would be checked here if present.
    }

    // 6. Freeze and Return
    return Object.freeze({
        ...envelope,
        ...(certFingerprint ? { certFingerprint } : {})
    });
}

Great — here’s the exact “user” block you should drop into verifyIdentity.ts so Option A is enforced fail-closed and can’t be “accidentally” bypassed.

This does three things:

User OU path is explicitly defined (only allowed at ingress; never between internal services)

User must be tenant + participant anchored (participantId required)

User cannot “masquerade” as internal (trustTier, certFingerprint rules)

Replace your Step 4 block with this (complete)
// 4. Directional Trust Enforcement (OU Interaction Graph)
// Fail-closed OU routing + explicit "user" contract enforcement.
const allowed = ALLOWED_ISSUERS[currentService] ?? [];

// ---- USER SUBJECTTYPE CONTRACT (Option A) ----------------------------------
// Users are human actors scoped to a participant tenancy.
// They only enter the system at ingress (typically ingest-api), issued by client.
// Users MUST NOT be propagated service-to-service.
if (envelope.subjectType === 'user') {
    // 4.A: Users may ONLY be verified at the ingress boundary (PaC contract)
    // If you later want to allow user identities at read-api, do it explicitly
    // with a second allowlist and a separate threat model.
    if (currentService !== 'ingest-api') {
        throw new Error(
            `User identity is only permitted at ingest-api boundary. Got currentService=${currentService}`
        );
    }

    // 4.B: Users may ONLY be issued by the client boundary (browser/mobile/API gateway)
    // This prevents internal services from minting "user" envelopes.
    if (envelope.issuerService !== 'client') {
        throw new Error(
            `User identity must be issued by client only. Got issuerService=${envelope.issuerService}`
        );
    }

    // 4.C: Tenant anchoring invariant
    if (!envelope.tenantId || envelope.tenantId.trim().length === 0) {
        throw new Error("User identity invalid: tenantId is required");
    }

    // 4.D: Participant anchoring invariant (Option A requirement)
    if (!envelope.participantId || envelope.participantId.trim().length === 0) {
        throw new Error("User identity invalid: participantId is required");
    }

    // 4.E: Trust tier separation (no escalation)
    // Recommended: user trustTier should remain 'external' (do

This got cut off. Re explain:
import { IdentityEnvelopeV1, ValidatedIdentityContext } from "./identity.js";
import { validatePolicyVersion } from "../db/policy.js";
import { TrustFabric } from "../auth/trustFabric.js";
import crypto from "crypto";
import { KeyManager } from "../crypto/keyManager.js";

// OU Interaction Graph (Phase 3)
// Allowed issuers for each service/OU
const ALLOWED_ISSUERS: Record<string, string[]> = {
    'control-plane': ['client', 'ingest-api'], // OU-01/OU-03 accepts from Client or Ingest
    'ingest-api': ['client'],                // OU-04 accepts from Client
    'executor-worker': ['control-plane'],     // OU-05 accepts from Control Plane (OU-03)
    'read-api': ['executor-worker'],          // OU-06 accepts from Executor (OU-05)
};

// SEC-7R-FIX: Clock skew tolerance and max token age
const CLOCK_SKEW_MS = 30_000; // 30 seconds
const MAX_TOKEN_AGE_MS = 5 * 60 * 1000; // 5 minutes

/**
 * Verifies the identity envelope and returns a validated, immutable context.
 * Throws on any violation (Fail-Closed).
 * 
 * SEC-7R-FIX: Implements timing-safe comparison, canonical JSON, and freshness checks.
 */
export async function verifyIdentity(
    envelope: IdentityEnvelopeV1,
    currentService: string,
    keyManager: KeyManager, // Dependency Injection (INV-SEC-04)
    certFingerprint?: string // Phase 6.4: Optional for clients, mandatory for services
): Promise<ValidatedIdentityContext> {

    // 1. Basic Schema & Version Validation
    if (envelope.version !== 'v1') throw new Error("Unsupported identity version");

    // SEC-7R-FIX: Token freshness check with clock skew tolerance
    const issuedAt = new Date(envelope.issuedAt).getTime();
    const now = Date.now();
    if (isNaN(issuedAt)) {
        throw new Error("Invalid issuedAt timestamp");
    }
    if (now - issuedAt > MAX_TOKEN_AGE_MS + CLOCK_SKEW_MS) {
        throw new Error("Identity token too old - re-authentication required");
    }
    if (issuedAt > now + CLOCK_SKEW_MS) {
        throw new Error("Identity token issued in the future");
    }

    // 2. SEC-7R-FIX: Canonical JSON with sorted keys for deterministic signatures
    // Includes trustTier and certFingerprint for complete binding
    const dataToSign = JSON.stringify({
        certFingerprint: envelope.certFingerprint ?? null,
        issuedAt: envelope.issuedAt,
        issuerService: envelope.issuerService,
        policyVersion: envelope.policyVersion,
        requestId: envelope.requestId,
        roles: envelope.roles.slice().sort(), // Sorted for determinism
        subjectId: envelope.subjectId,
        subjectType: envelope.subjectType,
        tenantId: envelope.tenantId,
        trustTier: envelope.trustTier ?? null,
        version: envelope.version,
    });

    const expectedSignature = crypto
        .createHmac('sha256', await keyManager.deriveKey('identity/hmac'))
        .update(dataToSign)
        .digest('hex');

    // SEC-7R-FIX: Timing-safe comparison to prevent timing attacks
    const sigBuffer = Buffer.from(envelope.signature, 'hex');
    const expectedBuffer = Buffer.from(expectedSignature, 'hex');

    if (sigBuffer.length !== expectedBuffer.length ||
        !crypto.timingSafeEqual(sigBuffer, expectedBuffer)) {
        throw new Error("Invalid identity signature");
    }

    // 3. Policy Version Validation
    // SEC-7R-FIX: Enforce active policy version matching.
    await validatePolicyVersion(envelope.policyVersion);

    // 4. Directional Trust Enforcement (OU Interaction Graph)
    const allowed = ALLOWED_ISSUERS[currentService];
    if (!allowed || !allowed.includes(envelope.issuerService)) {
        // Special case for initial client requests
        if (envelope.subjectType === 'client' && allowed && allowed.includes('client')) {
            // Allowed
        } else if (envelope.subjectType === 'user') {
            // Finding #5: 'user' subject type supported in Phase 7B
            // User identity must be validated against allowed issuers (e.g. client)
        } else {
            throw new Error(Unauthorized OU interaction: ${envelope.issuerService} -> ${currentService});
        }
    }



    // 5. Phase 6.4: mTLS & Trust Fabric Enforcement
    if (envelope.subjectType === 'service') {
        if (!certFingerprint) {
            throw new Error("mTLS Violation: Service-to-service calls require cryptographic proof.");
        }

        const identity = TrustFabric.resolveIdentity(certFingerprint);
        if (!identity) {
            throw new Error("mTLS Violation: Revoked or untrusted certificate.");
        }

        // Bind mTLS claim to envelope subject
        if (identity.serviceName !== envelope.issuerService) {
            throw new Error(mTLS Violation: Certificate identity (${identity.serviceName}) mismatch with claim (${envelope.issuerService}).);
        }

        // Ensure OU consistency
        // In a real system, envelope.ou would be checked here if present.
    }

    // 6. Freeze and Return
    return Object.freeze({
        ...envelope,
        ...(certFingerprint ? { certFingerprint } : {})
    });
}

Yep — the part that got cut off was the actual “user subjectType” enforcement block that should replace your current Step 4. Here’s the clean mental model and then the exact code drop-in.

What Step 4 is supposed to mean

Right now, Step 4 (“Directional Trust Enforcement”) is enforcing OU routing:

Which issuerService is allowed to call which currentService

For example:

client -> ingest-api allowed

control-plane -> executor-worker allowed

executor-worker -> read-api allowed

But your current Step 4 has a hole:

} else if (envelope.subjectType === 'user') {
  // TODO: user identity must be validated...
}


That effectively means:
✅ user doesn’t get blocked here
❌ but also no rules are actually enforced

So we need to make “user” unambiguous:

User contract (Option A)

A user is a human actor.

A user is always anchored to a tenant AND a participant.

A user must remain external trust tier (cannot become internal).

A user is not validated via TrustFabric mTLS (that’s for services).

A user must only be accepted at ingress boundaries (typically ingest-api, and optionally read-api if you explicitly allow it).

That’s all Step 4’s job: decide if this identity is even allowed to be here.

The code you should use (drop-in replacement for Step 4)

Replace your entire Step 4 block with this:

// 4. Directional Trust Enforcement (OU Interaction Graph)
// Fail-closed routing rules + explicit user contract.
const allowed = ALLOWED_ISSUERS[currentService] ?? [];

// -------------------- USER SUBJECTTYPE CONTRACT (Option A) --------------------
if (envelope.subjectType === 'user') {
    // A) Users are only accepted at explicit boundaries.
    // Start strict: only ingest-api. If you later want read-api, add it explicitly.
    const USER_ENTRYPOINTS = new Set(['ingest-api']); // optionally add 'read-api'
    if (!USER_ENTRYPOINTS.has(currentService)) {
        throw new Error(
            `User identity not permitted at ${currentService}. Users may only enter at: ${Array.from(USER_ENTRYPOINTS).join(', ')}`
        );
    }

    // B) Users must be issued by the boundary issuer.
    // Most conservative: only "client" can mint/forward a user envelope into ingest-api.
    if (envelope.issuerService !== 'client') {
        throw new Error(
            `User identity must be issued by client. Got issuerService=${envelope.issuerService}`
        );
    }

    // C) Tenant anchoring (non-negotiable)
    if (!envelope.tenantId || envelope.tenantId.trim().length === 0) {
        throw new Error("User identity invalid: tenantId is required");
    }

    // D) Participant anchoring (Option A requirement)
    if (!envelope.participantId || envelope.participantId.trim().length === 0) {
        throw new Error("User identity invalid: participantId is required");
    }

    // E) Trust-tier separation: user cannot claim internal trust
    if (envelope.trustTier !== 'external') {
        throw new Error(
            `User identity invalid: trustTier must be 'external'. Got ${envelope.trustTier}`
        );
    }

    // F) Users must not present mTLS binding fields (avoid confusion with service semantics)
    // (If you choose to allow client certs for user transport later, handle that as a distinct design.)
    if (envelope.certFingerprint) {
        throw new Error("User identity invalid: certFingerprint must not be set for subjectType='user'");
    }

    // If we got here: user is allowed (and anchored), no OU graph check needed beyond this.
} else {
    // -------------------- NON-USER: ORIGINAL OU GRAPH RULES --------------------
    if (!allowed.includes(envelope.issuerService)) {
        // Special case: first hop from client into services that allow it
        if (envelope.subjectType === 'client' && allowed.includes('client')) {
            // Allowed
        } else {
            throw new Error(`Unauthorized OU interaction: ${envelope.issuerService} -> ${currentService}`);
        }
    }
}

Why this fixes your architecture question (“why push it back?”)

I’m not pushing it back — the problem was that your current code effectively says “user exists” but doesn’t constrain it, which is exactly how invariants get accidentally bypassed later.

This keeps user in the architecture now, while preserving Phase-7 invariants:

No cross-tenant: enforced by mandatory tenantId + participantId anchoring.

No escalation: enforced by trustTier === 'external'.

No service impersonation: users can’t appear in internal hops (executor-worker, control-plane) because we fail closed unless they’re at an explicit boundary.

OU graph stays intact: user doesn’t dilute OU trust rules for service-to-service.

One more necessary follow-up (otherwise signatures don’t bind participantId)

Right now your dataToSign does not include participantId / participantRole / participantStatus, so those fields can be altered without breaking signature verification.

Add these fields to your dataToSign object:

participantId: envelope.participantId ?? null,
participantRole: envelope.participantRole ?? null,
participantStatus: envelope.participantStatus ?? null,


That’s critical for Option A, since participant anchoring must be tamper-proof.