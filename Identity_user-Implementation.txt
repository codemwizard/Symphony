You’re very close, but the plan as written has internal contradictions and mixes two different governance models (old “policy version in DB / active-policy.json” vs new “PaC pinned by submodule + .policy.lock”). If you don’t cleanly choose one, you’ll keep getting CI “mystery failures.”

Here’s my advice: treat PaC as the only source of truth for policy provenance in CI, and stop coupling policy checks to Postgres for Phase-7B. Then handle DB TLS + schema correctness separately.

What’s good in your plan
✅ Correct themes for Phase-7B

CI stability, lint baseline, DB TLS fail-closed, identity schema ambiguity cleanup — all appropriate.

Moving away from ajv-cli and npx -p hacks is the right direction.

✅ PaC direction is correct

.policy.lock + .policies submodule HEAD as provenance is unambiguous and regulator-friendly.

Evidence bundle should record the locked commit hash, not a version string.

What’s wrong / conflicting (must fix)
1) Identity decision contradicts itself

You wrote:

“Proceeding with removing implicit subjectType='user' support”
but later:

“Retain subjectType='user'. Validate explicitly…”

Pick one. Given your Phase-7R/7B trust model (“Participant/System”), the clean Phase-7B move is:

Recommendation (7B): remove user from the schema and reject it in verifyIdentity.
If you later need “user” identities, reintroduce it in Phase-8 with explicit issuer/JWKS trust and a separate authorization path.

2) CI DB “policy checks” are obsolete under PaC

You still reference:

.github/workflows/ci.yml

check_policy_version.sh

seeding policy version into DB

Those belong to the old model. Under PaC:

Policy is not in Postgres

CI should not query Postgres to validate policy

Postgres is only there to run migrations/tests.

So: delete any “policy version ↔ DB” verification in 7B.

3) You’re splitting Ajv v3+ into “Phase 8+” but you already need it now

Ajv v3+ formats support is currently a blocking CI stability issue, not a Phase-8 upgrade. If evidence validation is in Phase-7B scope (it is), then Ajv v8/2020 + formats v3 belongs in Phase-7B final polish, not Phase-8.

4) Your “Task list” mixes unrelated failures and repeats

Items like:

missing update_updated_at_column() in 000_ulid.sql

missing triggers in migrations

table rename conflicts

Those are DB schema correctness tasks, not “CI stability via PGSSLMODE.” Keep them as a separate workstream with clear owners, otherwise Phase-7B never finishes.

Recommended Phase-7B plan (clean, unambiguous)
Workstream A — CI Stability (DB connection)

Goal: CI always connects to the ephemeral Postgres.

In CI job env: keep

PGSSLMODE=disable only in CI

Ensure psql is available (Ubuntu usually has it; if not, install postgresql-client).

Keep DB checks limited to: migrations + tests.

Acceptance: migrations apply + tests run without connection flakiness.

Workstream B — ESLint baseline

Goal: “no warnings” in runtime code, pragmatic allowances in scripts.

Strict in libs/** and services/** (no-console error, no-any error).

Allow console in operational glue:

scripts/**, .ci/**, ci/**, .github/**

CI runs: npm run lint -- --max-warnings=0.

Acceptance: lint is deterministic and blocks merges.

Workstream C — Database TLS enforcement (prod/staging only)

Goal: fail-closed when NODE_ENV=production (and optionally staging).

In libs/db/index.ts:

If NODE_ENV in {production, staging}:

require DB_CA_CERT (or path)

force ssl: { rejectUnauthorized: true, ca: ... }

Else:

allow ssl: false or developer-controlled settings

Acceptance: unit test proves prod fails without CA; dev/ci do not require CA.

Workstream D — Identity schema cleanup

Goal: remove ambiguity and close auth gaps.

Recommendation for 7B:

Remove subjectType: "user" from schema OR make it invalid.

In verifyIdentity.ts, if subjectType === "user" → reject with a specific error code.

Acceptance: tests confirm user is rejected; participant/system flows still pass.

Workstream E — PaC + Evidence Validation (Ajv v8 2020 + formats v3)

This is the part you’re trying to finish right now.

PaC source of truth: .policy.lock (pinned commit) + .policies submodule HEAD

CI step:

scripts/ci/verify_policy_lock.sh (fail-closed)

Evidence generation:

reads .policy.lock, verifies it matches .policies

writes policy_commit_hash = locked commit

sets policy_version_verified = true only if verified

Evidence validation:

replace ajv-cli with Node ESM validator script using:

ajv/dist/2020.js

ajv-formats v3

Acceptance: CI passes using formats v3+, no “module invalid” errors, and evidence always reflects the locked policy commit.

What I would change in your document (concrete edits)
Remove from Phase-7B entirely

Anything referencing check_policy_version.sh or “policy version in DB”

Anything referencing active-policy.json

Move into Phase-7B (not Phase-8)

Ajv v8/2020 + ajv-formats v3 evidence validation

PaC fail-closed verification

Resolve identity contradiction

Pick one; I recommend:

7B: remove/reject user

8+: reintroduce only with explicit IdP/JWKS trust + separate authz model

Why your AJV v3+ was failing in GitHub

The error you saw (“module ajv-formats is invalid; it should export function”) is classic CLI + module format mismatch:

ajv-cli@5 is often pulled/used in ways that expect CommonJS plugin loading

ajv-formats@3 is ESM-first and doesn’t behave the same under require()-style plugin loading

So the fix is structural:
stop using ajv-cli and validate via a Node ESM script (Ajv2020 + addFormats). That’s the least painful and most deterministic approach in your NodeNext/ESM repo.

Final recommendation

Yes, do this — but merge and simplify:

Phase-7B = stability + lint + prod TLS + identity cleanup + PaC + Ajv v3 validation

Phase-8 = new capabilities (evidence export, survivability, etc.), not CI plumbing

If you want, paste your schemas/evidence-bundle.schema.json top section (the $schema and any $defs/unevaluatedProperties usage). I’ll tell you the one Ajv2020 config flag you might need (or not) to keep it strict without false failures.

There is a confusion with my team. I expressly stated that I want user imbedded in the architecture right now. It is a vital and necessary part of the plans for the money transfer and NGO-based close-loop community projects. It has already been implemented buy this must be residual documentation from the time we were discussing it.
My question is why do you want it to be pushed back when it is an architectural implementation that leaves off of the invariants in place?

I’m not “against user” as a concept. I was pushing it back only because in many systems “user” ends up being a second trust model (human sessions, OAuth/OIDC, browser/mobile clients, refresh tokens, step-up auth, device binding, etc.). If you introduce that implicitly (or half-implemented) it can punch holes straight through Phase-7R invariants.

If you’re explicitly saying:

User is required now

User support is already implemented

And you still want Phase-7R/7B invariants to hold

…then the right move is not “remove user.” The right move is: make user unambiguous and invariant-preserving.

Below is the reasoning, and the exact conditions under which “user now” is safe.

Why I previously recommended pushing it back (the real risk)

“user” becomes dangerous when it is treated as equivalent to “participant/system” without:

Cryptographic verification that binds the identity to the right trust tier

e.g., placeholder JWT verification, weak claim binding, no issuer/audience enforcement

Clear authorization semantics

“user” often implies end-user privileges; “participant/system” implies institutional privileges

if you don’t separate capability scopes, you get privilege confusion

Replay + freshness controls

user tokens are replayable by default unless you enforce iat/exp, nonce/jti, max age, etc.

Request context isolation

“user” plus global RequestContext = cross-request identity bleed = broken access control

So the “pushback” was a defensive move against implicit “user” support.

When “user now” is absolutely compatible with Phase-7R invariants

If you define “user” as a first-class subject type with strict semantics, it can strengthen the architecture.

Keep Phase-7R invariants intact by enforcing these invariants for subjectType=user
Invariant A — No Ingress → No Execution (Attestation)

A user-originated request must still:

pass ingress attestation middleware before any execution

be hash-chained like everything else

✅ No conflict. User identity is orthogonal to attestation.

Invariant B — Atomic Dispatch (ledger + outbox)

Whether the caller is user or participant/system:

the ledger mutation and outbox row are still written in one DB transaction

✅ No conflict. Caller identity affects authorization not the atomic write boundary.

Invariant C — Idempotency + Retry safety

User flows often increase retries (mobile networks), so you must ensure:

user-initiated transfer requests carry an idempotency key / txId

duplicates are rejected deterministically

✅ User actually makes idempotency more important, not less.

Invariant D — Policy consistency

User tokens must be checked against:

active policy state (in-memory cached state in runtime)

or policy commit pin (PaC) for CI/evidence—different concern

✅ No conflict, but user is where policy/version enforcement matters most.

The only thing you must NOT do: “user” as a synonym for “participant”

This is where teams get into trouble.

If user is vital for closed-loop NGO/community flows, the clean model is:

Two trust tiers, one execution engine

Participant/System: institutional callers (mTLS, cert-bound identity)

User: human actor operating under a participant tenancy (OIDC/JWT, device-bound, etc.)

Key rule: every user must be anchored to a participant tenancy:

participant_id is mandatory on user identity

authorization checks must validate user actions are within that participant’s scope

That avoids “a user becomes a global super-user.”

What “unambiguous user” looks like (practical spec)

If you want user embedded now, I’d align the team on this contract:

1) Identity envelope must bind these fields for user

Minimum required claims for subjectType=user:

subject_type: "user"

subject_id (user id)

participant_id (tenant anchor — required)

trust_tier: "user"

issuer, audience

iat, exp (and enforce max token age)

jti (optional but recommended for replay controls)

policy_version or policy_commit depending on your runtime model

capabilities (or roles that map to capabilities)

2) Verification must be real, not placeholder

For user JWT verification:

verify signature (ES256 is a solid pick)

validate iss/aud/exp/iat

enforce max token age (e.g., 5 minutes) to limit replay window

bind additional fields into signature-critical claims:

participant_id, trust_tier, policy_version/commit, key fingerprint (where applicable)

3) Authorization must be explicit

requireCapability() must:

treat user capabilities as a subset of participant/system capabilities

enforce tenant boundary: claims.participant_id must match target resources

4) Observability/evidence must include “who did what”

Ingress attestation should record:

subject type

subject id hash (or redacted form)

participant id

capability decision outcome
…without leaking secrets

This helps regulators later, and it helps you debug.

Why this “builds off invariants” rather than breaking them

Because the invariants you care about (attestation-first, atomic outbox, monotonic ids, zombie repair bounds) are execution safety invariants.

“user” is an identity + authorization surface.

As long as user is:

cryptographically verified

tenant-anchored

capability-scoped

request-context isolated (ALS)
…it does not weaken execution invariants; it just controls who is allowed to trigger them.

The real reason teams get confused

A lot of architectures accidentally do:

Participant = institution

User = “someone”

And then they reuse the same authorization pathway without strict separation

That’s where audits flag “ambiguous subject type support.”

So the correction is not “remove user.” It’s “stop letting user be ambiguous.”

Bottom line

I only wanted to push it back if “user” was implicit / underspecified / placeholder-verified.
If “user” is a first-class, tenant-anchored, cryptographically verified subject type, then it’s absolutely a Phase-7B-safe implementation and it improves the robustness story.

If you want, I can write a one-page “User SubjectType Contract” you can drop into your docs that:

defines required claims

defines verification steps

defines allowed capabilities

and lists the exact invariants that must still hold (Phase-7R carryover)

That usually ends the team debate fast because it turns “user” into a crisp spec instead of a vibe.

Write the one-pager "User SubjectType Contract"
User SubjectType Contract (Symphony / Phase-7R+)

Status: Required (Phase-7R/7B)
Applies to: All request execution paths that accept subjectType = "user"
Goal: Embed user flows now without weakening the Phase-7R invariants (attestation-first, atomic dispatch, idempotency, policy lock integrity, and request-context isolation).

1) Definition & Intent
1.1 SubjectType: user

A user is a human actor initiating actions within a participant tenancy, and must never be treated as an unscoped global principal.

Core rule:
A user identity is valid only when it is tenant-anchored to a participant_id and is cryptographically verified.

1.2 Non-goals

This contract does not define PMaaS runtime policy distribution, sidecar enforcement, ingress attestation infrastructure, or database seed truth. This is PaC identity correctness for build + runtime verification logic.

2) Trust Model & Separation
2.1 Trust tiers

Two trust tiers exist and must remain distinct:

participant/system

Institutional actor (service identity, mTLS, signed service tokens)

Can trigger privileged operational flows

user

Human actor (JWT/OIDC-like)

Must be capability-scoped and tenant-anchored

2.2 Forbidden equivalence

It is forbidden to interpret:

subjectType=user as equivalent to participant/system

a missing subjectType as user

a missing participant_id as “inferable”

If any required field is missing: fail closed.

3) Required Identity Claims (User)

A request is considered “user-authenticated” only if the identity envelope contains the following required claims.

3.1 Required fields (minimum)
Field	Type	Requirement
subjectType	string	MUST equal "user"
subjectId	string	MUST be present, non-empty
participantId	string	MUST be present, non-empty (tenant anchor)
trustTier	string	MUST equal "user"
issuer (iss)	string	MUST be present and allowlisted
audience (aud)	string	MUST match service audience
issuedAt (iat)	number	MUST be present
expiresAt (exp)	number	MUST be present
capabilities OR roles	array	MUST be present (non-empty)
policyCommit OR policyVersion	string	MUST be present (see §6)
3.2 Optional but recommended
Field	Type	Use
jti	string	Replay protection / traceability
deviceId	string	Device binding for mobile flows
sessionId	string	Session scoping + auditing
authContext	object	Step-up / MFA / risk signals
4) Cryptographic Verification (Fail Closed)
4.1 Verification requirements

A user identity MUST be cryptographically verified before any execution logic:

Verify JWT signature using a pinned or fetched JWKS (allowlisted issuer)

Validate iss, aud

Validate exp (not expired)

Validate iat (not in the future beyond skew)

Enforce max token age (recommended ≤ 5 minutes for high-risk actions)

Validate required fields exist and match allowed formats

If any check fails → request MUST be rejected.

4.2 Clock skew

Allow a small skew (e.g., 60 seconds). Anything larger is a misconfiguration and should fail.

5) Authorization Rules (Capabilities & Tenant Anchor)
5.1 Tenant boundary is mandatory

For any operation that touches tenant-scoped resources:

claims.participantId MUST equal the resource tenant

No cross-tenant access is permitted unless explicitly defined as an administrative capability and audited

5.2 Capability-driven authorization

User authorization MUST be evaluated via explicit capability checks.

Examples:

TRANSFER_CREATE

TRANSFER_APPROVE

BENEFICIARY_ADD

LEDGER_VIEW

LEDGER_EXPORT

Roles are allowed only if they map deterministically to capabilities.
Do not implement “role strings” with ad-hoc logic.

5.3 Least privilege baseline

User capabilities MUST be strictly narrower than participant/system capabilities.

6) Policy Binding (PaC Compatibility)
6.1 Policy source of truth

For PaC, the policy repository pinned by `.policy

Is this accurate and answer my guidance questions at the bottom:
User Identity: Role, Capabilities, and Limitations
Role
A user is a human actor operating under a participant tenancy. Users are NOT institutional actors (those are participant or service). Users trigger actions but are always scoped and verified.

Capabilities (Permitted)
Trigger tenant-scoped financial flows (e.g., TRANSFER_CREATE, TRANSFER_APPROVE)
View their tenant's ledger data
Perform actions within their participantId boundary
User capabilities are a strict subset of participant/system capabilities
Limitations (Non-Negotiable)
Limitation	Description
Tenant Anchoring	participantId is MANDATORY. A user without a participant anchor is invalid.
Trust Tier Separation	trustTier for users must be "user" or "external". Cannot escalate to "internal".
No Cross-Tenant Access	claims.participantId MUST match the target resource's tenant. No global access.
Cryptographic Verification	JWT signature (ES256 or similar), iss, aud, exp, iat MUST be validated.
Token Freshness	Max token age enforced (≤5 minutes recommended). Expired tokens rejected.
Not a Participant Synonym	Users cannot exercise participant-level or system-level capabilities.
Current Implementation Gaps
Based on my code review of 
verifyIdentity.ts
, 
identity.ts
, and 
schema.ts
:

Gap	Location	Status
participantId is optional	
schema.ts
 line 26, 
identity.ts
 line 26	NOT ENFORCED for user
User verification logic is empty	
verifyIdentity.ts
 lines 89-94	PLACEHOLDER (no real check)
Issuer allowlist for user tokens	
verifyIdentity.ts
NOT IMPLEMENTED
Trust tier enforcement for user	
verifyIdentity.ts
NOT IMPLEMENTED
Where I Need Guidance
Issuer Allowlist: What specific issuers (e.g., auth0, cognito, symphony-auth) should be allowlisted for subjectType='user' tokens?
User Trust Tier Value: Should users have trustTier: 'user' (new enum value) or trustTier: 'external' (existing)?
JWKS/Key Verification: Should we implement full JWKS fetching for user JWTs, or use a pre-shared signing key similar to HMAC for services? (Full JWKS is more standard for OIDC flows.)

Yes — this is accurate in intent and it does answer the architectural direction you’ve set (“users are first-class, tenant-anchored humans”), but a couple of terms should be tightened so the contract is unambiguous and hard to misinterpret.

What’s accurate

User = human actor under participant tenancy (correct and necessary for closed-loop/NGO flows).

Strict tenant anchoring (participantId mandatory) is the right invariant.

No cross-tenant rule is essential and correctly stated.

Crypto verification + freshness is correct and aligns with Phase-7R posture.

Users are not participants/system is correctly explicit.

What I would tighten (small but important)

Trust tier wording

Saying trustTier must be "user" or "external" introduces ambiguity (“external” can mean many things).

Make it one canonical value for users, and treat “external” as a source attribute, not a tier.

Capabilities vs limitations

“View their tenant’s ledger data” is fine, but add: only via read models / filtered views; never raw tables unless read API is explicitly scoped.

“ES256 or similar”

Replace with “ES256 required” (or whichever you choose) to avoid drift.

Guidance answers (your three questions)
1) Issuer allowlist: which issuers?

Use an allowlist by environment + audience, not a single global list.

Recommended baseline:

Primary: symphony-auth (your own issuer, even if it is a thin wrapper over an upstream IdP)

Optional (only if you already run them): https://<your-auth0-tenant>/ or https://cognito-idp.<region>.amazonaws.com/<pool_id>

Rule of thumb: Allowlist issuers you can operationally control and rotate without “surprise” breaking changes. If you expect multiple community operators, put them behind symphony-auth so Symphony only trusts one issuer.

2) User trustTier value: 'user' or 'external'?

Use trustTier: "user" (new enum value).

Reason: external is a provenance concept (where the identity came from), not a privilege boundary. Your privilege boundary is:

system / participant (institutional)

user (human)

If you need to express provenance, add a separate field like:

identitySource: "oidc" | "mtls" | "internal-service", or

authMethod: "jwt" | "mtls"

3) JWKS fetching vs pre-shared signing key (HMAC)

For user tokens, do ES256 + JWKS (pinned).

Minimum viable, low-pain option (recommended now):

Keep a static JWKS file in repo (or in a config bucket) for sandbox/staging.

In production, switch to JWKS URL (OIDC well-known) with caching.

Avoid HMAC for users unless you are 100% sure you will never federate external IdPs. HMAC makes multi-issuer governance messy and increases blast radius (shared secret leakage).

One small correction to your “Implementation Gaps” section

Your gaps are plausible, but the line numbers might drift; the key is the requirements:

participantId must be required when subjectType=user

verifyIdentity must actually validate: iss/aud/exp/iat/jti(optional)/policyCommit

trustTier must be checked and must not be user-controllable escalation

Suggested “final wording” you can drop into your doc

Issuer allowlist: “Allowed issuers are environment-scoped and pinned. Default allowed issuer is symphony-auth. Additional issuers require explicit allowlist entry plus audience binding.”

Trust tier: “trustTier=user is required for subjectType=user. external is not a tier; provenance is represented via identitySource.”

Key verification: “User JWTs MUST be verified with ES256 against JWKS. In sandbox, JWKS may be pinned as a static file. In production, JWKS may be fetched from a well-known endpoint with caching and fail-closed semantics.”

If you paste your current verifyIdentity.ts and schema.ts (or the relevant excerpts), I can translate this contract into exact enforcement rules and a minimal patch list without expanding scope.

## verifyIdentity.ts

import { IdentityEnvelopeV1, ValidatedIdentityContext } from "./identity.js";
import { validatePolicyVersion } from "../db/policy.js";
import { TrustFabric } from "../auth/trustFabric.js";
import crypto from "crypto";
import { KeyManager } from "../crypto/keyManager.js";

// OU Interaction Graph (Phase 3)
// Allowed issuers for each service/OU
const ALLOWED_ISSUERS: Record<string, string[]> = {
    'control-plane': ['client', 'ingest-api'], // OU-01/OU-03 accepts from Client or Ingest
    'ingest-api': ['client'],                // OU-04 accepts from Client
    'executor-worker': ['control-plane'],     // OU-05 accepts from Control Plane (OU-03)
    'read-api': ['executor-worker'],          // OU-06 accepts from Executor (OU-05)
};

// SEC-7R-FIX: Clock skew tolerance and max token age
const CLOCK_SKEW_MS = 30_000; // 30 seconds
const MAX_TOKEN_AGE_MS = 5 * 60 * 1000; // 5 minutes

/**
 * Verifies the identity envelope and returns a validated, immutable context.
 * Throws on any violation (Fail-Closed).
 * 
 * SEC-7R-FIX: Implements timing-safe comparison, canonical JSON, and freshness checks.
 */
export async function verifyIdentity(
    envelope: IdentityEnvelopeV1,
    currentService: string,
    keyManager: KeyManager, // Dependency Injection (INV-SEC-04)
    certFingerprint?: string // Phase 6.4: Optional for clients, mandatory for services
): Promise<ValidatedIdentityContext> {

    // 1. Basic Schema & Version Validation
    if (envelope.version !== 'v1') throw new Error("Unsupported identity version");

    // SEC-7R-FIX: Token freshness check with clock skew tolerance
    const issuedAt = new Date(envelope.issuedAt).getTime();
    const now = Date.now();
    if (isNaN(issuedAt)) {
        throw new Error("Invalid issuedAt timestamp");
    }
    if (now - issuedAt > MAX_TOKEN_AGE_MS + CLOCK_SKEW_MS) {
        throw new Error("Identity token too old - re-authentication required");
    }
    if (issuedAt > now + CLOCK_SKEW_MS) {
        throw new Error("Identity token issued in the future");
    }

    // 2. SEC-7R-FIX: Canonical JSON with sorted keys for deterministic signatures
    // Includes trustTier and certFingerprint for complete binding
    const dataToSign = JSON.stringify({
        certFingerprint: envelope.certFingerprint ?? null,
        issuedAt: envelope.issuedAt,
        issuerService: envelope.issuerService,
        policyVersion: envelope.policyVersion,
        requestId: envelope.requestId,
        roles: envelope.roles.slice().sort(), // Sorted for determinism
        subjectId: envelope.subjectId,
        subjectType: envelope.subjectType,
        tenantId: envelope.tenantId,
        trustTier: envelope.trustTier ?? null,
        version: envelope.version,
    });

    const expectedSignature = crypto
        .createHmac('sha256', await keyManager.deriveKey('identity/hmac'))
        .update(dataToSign)
        .digest('hex');

    // SEC-7R-FIX: Timing-safe comparison to prevent timing attacks
    const sigBuffer = Buffer.from(envelope.signature, 'hex');
    const expectedBuffer = Buffer.from(expectedSignature, 'hex');

    if (sigBuffer.length !== expectedBuffer.length ||
        !crypto.timingSafeEqual(sigBuffer, expectedBuffer)) {
        throw new Error("Invalid identity signature");
    }

    // 3. Policy Version Validation
    // SEC-7R-FIX: Enforce active policy version matching.
    await validatePolicyVersion(envelope.policyVersion);

    // 4. Directional Trust Enforcement (OU Interaction Graph)
    const allowed = ALLOWED_ISSUERS[currentService];
    if (!allowed || !allowed.includes(envelope.issuerService)) {
        // Special case for initial client requests
        if (envelope.subjectType === 'client' && allowed && allowed.includes('client')) {
            // Allowed
        } else if (envelope.subjectType === 'user') {
            // Finding #5: 'user' subject type supported in Phase 7B
            // User identity must be validated against allowed issuers (e.g. client)
        } else {
            throw new Error(Unauthorized OU interaction: ${envelope.issuerService} -> ${currentService});
        }
    }



    // 5. Phase 6.4: mTLS & Trust Fabric Enforcement
    if (envelope.subjectType === 'service') {
        if (!certFingerprint) {
            throw new Error("mTLS Violation: Service-to-service calls require cryptographic proof.");
        }

        const identity = TrustFabric.resolveIdentity(certFingerprint);
        if (!identity) {
            throw new Error("mTLS Violation: Revoked or untrusted certificate.");
        }

        // Bind mTLS claim to envelope subject
        if (identity.serviceName !== envelope.issuerService) {
            throw new Error(mTLS Violation: Certificate identity (${identity.serviceName}) mismatch with claim (${envelope.issuerService}).);
        }

        // Ensure OU consistency
        // In a real system, envelope.ou would be checked here if present.
    }

    // 6. Freeze and Return
    return Object.freeze({
        ...envelope,
        ...(certFingerprint ? { certFingerprint } : {})
    });
}


## schema.ts

/**
 * Symphony Canonical Audit Schema — v1
 * Phase Key: SYM-33
 * 
 * Objectives:
 * - Immutability
 * - Non-repudiation
 * - Regulator-grade forensics
 */

export type AuditEventType =
    | 'IDENTITY_VERIFY'
    | 'AUTHZ_ALLOW'
    | 'AUTHZ_DENY'
    | 'INSTRUCTION_SUBMIT'
    | 'INSTRUCTION_CANCEL'
    | 'EXECUTION_ATTEMPT'
    | 'EXECUTION_ABORT'
    | 'POLICY_ACTIVATE'
    | 'KILLSWITCH_ENGAGE'
    | 'EVIDENCE_EXPORT'
    | 'INCIDENT_SIGNAL'
    | 'CONTAINMENT_ACTIVATE'
    // Phase 7.1: Participant Identity & Guard Events
    | 'PARTICIPANT_RESOLVED'
    | 'PARTICIPANT_RESOLUTION_FAILED'
    | 'PARTICIPANT_STATUS_DENY'
    | 'GUARD_IDENTITY_DENY'
    | 'GUARD_AUTHORIZATION_DENY'
    | 'GUARD_POLICY_DENY'
    | 'GUARD_LEDGER_SCOPE_DENY'
    // Phase 7.2: Execution, Retry & Repair Events
    | 'EXECUTION_ATTEMPT_CREATED'
    | 'EXECUTION_ATTEMPT_SENT'
    | 'EXECUTION_ATTEMPT_RESOLVED'
    | 'RETRY_EVALUATED'
    | 'RETRY_ALLOWED'
    | 'RETRY_BLOCKED'
    | 'REPAIR_INITIATED'
    | 'REPAIR_RECONCILIATION_RESULT_RECORDED'
    | 'REPAIR_COMPLETED';

export interface AuditRecordV1 {
    eventId: string;        // UUID
    eventType: AuditEventType;
    timestamp: string;      // ISO-8601
    requestId: string;
    tenantId: string;
    subject: {
        type: 'client' | 'service';
        id: string;           // subjectId
        ou: string;           // issuerService / currentService
        certFingerprint?: string; // Phase 6.4: mTLS proof
    };
    action: {
        capability?: string;
        resource?: string;    // instructionId, providerId, etc.
    };
    decision: 'ALLOW' | 'DENY' | 'EXECUTED';
    policyVersion: string;
    reason?: string;
    integrity: {
        prevHash: string;     // Hash of the immediately preceding record
        hash: string;         // SHA-256(this_record_serialized || prevHash)
    };
}

Got it. Two big takeaways from what you pasted:

verifyIdentity.ts already supports “user” as an envelope subjectType, but the enforcement is currently incomplete/ambiguous (it “mentions” user, but doesn’t constrain it).

Your audit schema currently cannot represent user identities at all, because subject.type is only 'client' | 'service'. That will cause “residual documentation / confusion” forever, because your audit layer contradicts your runtime intent.

Below is the minimal, Phase-7B-appropriate patch set that makes user unambiguous, tenant-anchored, and non-escalatory—without requiring you to swap the whole identity envelope to JWT immediately.

1) Clarify the model: User tokens vs Symphony IdentityEnvelope

Right now, verifyIdentity() verifies an internal Symphony identity envelope (HMAC signature using KeyManager). That implies:

User JWT verification happens before this (at ingress / edge / gateway), and

Symphony then mints an IdentityEnvelopeV1 for downstream internal services.

That is totally fine for Phase-7B.

Contract you should enforce now (unambiguous):

subjectType="user" means: human actor.

User requests enter at ingress, get verified (JWT etc.), then are wrapped into a signed Symphony envelope.

Internal services trust the envelope signature and enforce scope; they do not accept raw user JWTs.

This is the “cleanest” way to keep your OU graph and mTLS story intact.

2) Required changes in verifyIdentity.ts (minimal, fail-closed)
A. Add explicit User Contract checks (tenant anchor + tier + issuer path)

Right after policy validation (after step 3) is a good place.

Rules:

tenantId MUST be present and non-empty for subjectType === 'user' (this is your participant anchor).

trustTier MUST equal "user" (do not allow "internal" or "external" ambiguity).

certFingerprint MUST be absent for user envelopes (or ignored) to avoid fake “mTLS privilege”.

issuerService MUST be in a user-issuer allowlist (ex: client and/or ingest-api) depending on your architecture.

OU interaction graph must treat user as not a service: users should only be accepted at entry surfaces (typically ingest-api, maybe control-plane).

B. Make OU enforcement deterministic for user

Right now you have:

} else if (envelope.subjectType === 'user') {
  // ... comment
} else {
  throw ...
}


That comment block needs to become an actual rule.

Here’s the exact drop-in patch pattern:

// after await validatePolicyVersion(...)

if (envelope.subjectType === "user") {
  // Tenant anchoring (your invariant)
  if (!envelope.tenantId || envelope.tenantId.trim().length === 0) {
    throw new Error("User identity invalid: tenantId (participant anchor) is required");
  }

  // Trust-tier: single canonical value
  if (envelope.trustTier !== "user") {
    throw new Error(`User identity invalid: trustTier must be "user" (got ${String(envelope.trustTier)})`);
  }

  // Users are not mTLS principals
  if (certFingerprint) {
    throw new Error("User identity invalid: user requests must not present mTLS service proof");
  }

  // User issuer constraint (who is allowed to mint/forward user envelopes)
  // Choose ONE of these approaches:
  // 1) Only the edge/ingest layer can present user envelopes:
  const USER_ALLOWED_ISSUERS = ["client", "ingest-api"];
  if (!USER_ALLOWED_ISSUERS.includes(envelope.issuerService)) {
    throw new Error(`User identity invalid: issuerService ${envelope.issuerService} not allowed for user`);
  }

  // AND: user envelopes only accepted by entry services
  const USER_ACCEPTING_SERVICES = ["ingest-api", "control-plane"]; // tighten to just ingest-api if possible
  if (!USER_ACCEPTING_SERVICES.includes(currentService)) {
    throw new Error(`User identity invalid: user identity cannot call ${currentService} directly`);
  }
}


Then your OU graph check can remain for non-user subjects.

C. Optional but recommended: bind issuer path for user envelopes

If you want zero ambiguity, add a field later like authMethod: "jwt" and/or identitySource, but that’s Phase-7R/8 polish—not required to unblock correctness.

3) Required changes in schema.ts (your audit contract is currently wrong)

Your audit schema must be able to represent a user, otherwise the architecture will always look “unsupported”.

A. Expand subject type union

Change:

type: 'client' | 'service';


to:

type: 'client' | 'service' | 'user';

B. Enforce tenant anchoring at the audit level

You already have tenantId at the record top-level (good). For user traceability, consider also adding participant anchor explicitly in the subject block (optional but clarity improves):

subject: {
  type: 'client' | 'service' | 'user';
  id: string;
  ou: string;
  tenantId?: string; // optional duplication for audit readability (record already has tenantId)
  certFingerprint?: string;
};


If you keep it only at record level, that’s okay—but don’t lose it.

C. Prevent “user = service” confusion in audit

Keep certFingerprint meaningful:

present for subject.type === 'service'

absent for user/client

This matches the contract you’re enforcing in verifyIdentity().

4) One subtle issue: your signature canonicalization isn’t fully canonical

You wrote “sorted keys” but you’re relying on JSON.stringify({ ...literal... }) order.

In modern Node, object literal insertion order is stable, so this is OK operationally as long as both signer and verifier use the exact same structure. But it’s not “true canonical JSON” in a cryptographic spec sense.

Phase-7B practical fix (minimal):

Keep what you have, but rename the comment to “deterministic serialization” not “canonical JSON”.

If you want real canonical JSON later, introduce a canonicalizer function (Phase-8).

5) Why pushing “user” back would be wrong here

Because your invariants already assume:

tenant/participant anchoring

scoped capabilities

explicit trust-tier separation

“User” is not a relaxation; it’s an explicit actor type. The risk is not the existence of users—it's allowing “user” to be underspecified (optional tenantId, ambiguous trustTier, issuer path undefined). Your patch should remove that ambiguity, not remove the user type.

6) What I need you to decide (one decision, not a long back-and-forth)

Pick ONE:

Option A (recommended): user envelopes only accepted by ingest-api (and maybe control-plane if you truly need it)

Option B: user envelopes can be accepted by multiple services (harder to reason about; I don’t recommend unless you have a strong reason)

If you say “Option A”, I’ll give you the final exact ALLOWED_ISSUERS + USER_ACCEPTING_SERVICES tables that align with your OU graph.

If you don’t want to decide, default to Option A—it’s the safest and most compliant.

Option A

Option A locked in ✅ — user identities are only accepted at the entry surface (ingest-api).

Below is the exact enforcement table + the minimal code patches to make “user” unambiguous and fail-closed, while keeping your existing OU graph + invariants intact.

1) Policy tables for Option A
User envelope acceptance (hard boundary)

User identities are only valid at: ingest-api

User identity issuer allowed to present at ingest-api: client (only)

That means:

subjectType	currentService	allowed issuerService
user	ingest-api	client

This is the cleanest “entry-only” posture and aligns with your OU graph intent.

2) Patch: verifyIdentity.ts (make user enforcement real)
Add these constants near the top (next to ALLOWED_ISSUERS)
// Option A (Phase-7B): user identities are entry-surface only
const USER_ACCEPTING_SERVICES = ['ingest-api'] as const;
const USER_ALLOWED_ISSUERS = ['client'] as const;

// Canonical trust-tier value for user identities (prevents ambiguity)
const USER_TRUST_TIER = 'user' as const;

Add this fail-closed user contract block right after policy validation:

Put it immediately after:

await validatePolicyVersion(envelope.policyVersion);


Add:

// 3.5 User SubjectType Contract (Option A: entry-only)
// Users must be tenant-anchored and never treated as mTLS principals.
if (envelope.subjectType === 'user') {
    // Entry surface only
    if (!USER_ACCEPTING_SERVICES.includes(currentService as any)) {
        throw new Error(`User identity invalid: user identities may only be accepted by ${USER_ACCEPTING_SERVICES.join(', ')}`);
    }

    // Allowed issuer path (who is allowed to present a user envelope to ingest-api)
    if (!USER_ALLOWED_ISSUERS.includes(envelope.issuerService as any)) {
        throw new Error(`User identity invalid: issuerService ${envelope.issuerService} not allowed for user`);
    }

    // Tenant anchoring (participant tenancy invariant)
    if (!envelope.tenantId || envelope.tenantId.trim().length === 0) {
        throw new Error('User identity invalid: tenantId (participant anchor) is required');
    }

    // Trust-tier separation (no escalation)
    if (envelope.trustTier !== USER_TRUST_TIER) {
        throw new Error(`User identity invalid: trustTier must be "${USER_TRUST_TIER}"`);
    }

    // Users are not mTLS principals (prevents privilege confusion)
    if (certFingerprint) {
        throw new Error('User identity invalid: user requests must not present service mTLS proof');
    }
}

Tighten your OU enforcement block so user doesn’t “fall through”

Replace your current “user comment block” with a hard decision:

} else if (envelope.subjectType === 'user') {
    // If we got here, user failed entry-only checks above OR is being presented to a non-entry service
    throw new Error(`Unauthorized OU interaction for user: ${envelope.issuerService} -> ${currentService}`);
}


That makes user handling deterministic (no placeholder).

3) Patch: schema.ts (audit must represent user)

Right now your audit schema contradicts your architecture.

Change:

type: 'client' | 'service';


to:

type: 'client' | 'service' | 'user';


Optionally (recommended for clarity), add an explicit tenant anchor to subject (even though AuditRecordV1 already has tenantId):

tenantId?: string; // optional duplication for readability (record already has tenantId)


And keep this invariant in code: certFingerprint should only be present when type === 'service'.

4) What this achieves (why it matches your invariants)

No widening of trust: user cannot appear anywhere except ingress.

No privilege confusion: user cannot be “service-like” (no mTLS binding, no OU traversal).

Tenant-scoped by construction: tenantId required.

Trust tier non-escalatory: must be "user".

This doesn’t “push user back” — it makes user architecturally safe.

5) One small guidance answer you asked earlier (now that Option A is chosen)

Issuer allowlist for user tokens:
For the internal envelope layer: issuerService = "client" only (because only the edge request can originate user intent).

If later you move to “ingest-api verifies JWT and mints envelope”, then you’ll switch to:

user envelope issuerService = "ingest-api" (because ingest is minting it)

and update USER_ALLOWED_ISSUERS accordingly

…but that’s a controlled, single-line change when you reach that step.

If you want, paste your current IdentityEnvelopeV1 type definition (libs/context/identity.ts) and I’ll give you the exact type-level tightening (e.g., making tenantId required when subjectType === 'user') without breaking other subject types.

/**
 * Symphony Identity Envelope (v1)
 * Cryptographically verifiable identity context
 *
 * Phase 7.1 Enhancement:
 * Added participant identity fields for regulated actor tracking.
 */

import type { ParticipantRole, ParticipantStatus } from '../participant/participant.js';

export interface IdentityEnvelopeV1 {
    version: 'v1';
    requestId: string;
    issuedAt: string;        // ISO-8601
    issuerService: string;   // e.g. 'control-plane', 'ingest-api'
    subjectType: 'client' | 'service' | 'user';
    subjectId: string;       // client_id or service_id
    tenantId: string;
    policyVersion: string;
    roles: string[];         // DB / service roles
    signature: string;       // HMAC-sha256 in v1
    trustTier: 'external' | 'internal';
    certFingerprint?: string; // Phase 6.4: mTLS proof

    // Phase 7.1: Participant Identity (Regulated Actor)
    participantId?: string;           // Resolved participant ID
    participantRole?: ParticipantRole;    // BANK, PSP, OPERATOR, SUPERVISOR
    participantStatus?: ParticipantStatus; // ACTIVE, SUSPENDED, REVOKED
}

export type ValidatedIdentityContext = Readonly<IdentityEnvelopeV1>;

Perfect — this type is exactly where we make Option A unambiguous at compile-time, not just runtime.

Right now you have two mismatches with the contract we want:

trustTier doesn’t include "user" (but Option A needs it).

tenantId is required (good), but participantId is optional (bad for “user is anchored to participant tenancy”).

Below is the cleanest “least pain” tightening that keeps compatibility and makes “user” explicit.

1) Make the envelope a discriminated union (TypeScript-enforced contract)

Replace your current IdentityEnvelopeV1 interface with this union:

import type { ParticipantRole, ParticipantStatus } from '../participant/participant.js';

type BaseEnvelopeV1 = {
  version: 'v1';
  requestId: string;
  issuedAt: string;        // ISO-8601
  issuerService: string;   // e.g. 'control-plane', 'ingest-api'
  subjectId: string;       // client_id / service_id / user_id
  tenantId: string;        // REQUIRED for all (good)
  policyVersion: string;
  roles: string[];         // capability roles
  signature: string;       // HMAC-sha256 in v1
  certFingerprint?: string; // mTLS proof (service-only at runtime)
  
  // Phase 7.1: Participant Identity (Regulated Actor)
  participantId?: string;
  participantRole?: ParticipantRole;
  participantStatus?: ParticipantStatus;
};

export type IdentityEnvelopeV1 =
  | (BaseEnvelopeV1 & {
      subjectType: 'service';
      trustTier: 'internal';
      certFingerprint: string;        // required for service envelopes
      // participantId optional; service calls may not be tied to a participant
    })
  | (BaseEnvelopeV1 & {
      subjectType: 'client';
      trustTier: 'external';
      // certFingerprint optional; client requests may not have mTLS
      // participantId optional; client may be pre-resolution
    })
  | (BaseEnvelopeV1 & {
      subjectType: 'user';
      trustTier: 'external' | 'user'; // allow 'user' if you want it, but see note below
      participantId: string;          // REQUIRED for users (tenant anchoring invariant)
      // certFingerprint must be absent/ignored at runtime (enforced in verifyIdentity)
    });

export type ValidatedIdentityContext = Readonly<IdentityEnvelopeV1>;

Why this is “Option A” correct

User must have participantId (compile-time enforced).

Service must have certFingerprint (compile-time enforced).

Still allows existing client flows without forcing participant resolution immediately.

2) Trust tier: pick one value and freeze it

You said “Option A”. For less confusion, I recommend:

User trustTier = "external" (and drop "user" entirely)

Because trustTier is about the trust boundary, not the subject type. “user” is already a subjectType.

So the tightest version is:

trustTier: 'external' | 'internal';


and for user branch:

trustTier: 'external';


If you keep "user" as a trustTier, you’ll end up maintaining two taxonomies forever (subjectType and trustTier) that overlap.

Recommendation (strong):

Keep trustTier as 'external' | 'internal'

User => 'external'

Service => 'internal'

3) Minimum runtime check updates you must keep

Even with the typing, keep these runtime invariants in verifyIdentity.ts:

If subjectType === 'user', reject if currentService !== 'ingest-api'

If subjectType === 'user', require issuerService in ['client']

If subjectType === 'user', require participantId (now redundant but good defense)

If subjectType === 'service', require certFingerprint AND TrustFabric match

This combination gives you: compile-time contract + fail-closed runtime enforcement.

4) Quick note on your earlier “User SubjectType Contract”

With this typing, your contract becomes mechanically true:

user is always tenant-anchored (tenantId + participantId)

user is never service (certFingerprint not required/expected)

user cannot propagate beyond ingress (runtime gate)

If you paste your verifyIdentity.ts current “user” section (the part that’s still a placeholder), I’ll rewrite it as a single crisp block that matches this union exactly and can’t be accidentally bypassed.

import { IdentityEnvelopeV1, ValidatedIdentityContext } from "./identity.js";
import { validatePolicyVersion } from "../db/policy.js";
import { TrustFabric } from "../auth/trustFabric.js";
import crypto from "crypto";
import { KeyManager } from "../crypto/keyManager.js";

// OU Interaction Graph (Phase 3)
// Allowed issuers for each service/OU
const ALLOWED_ISSUERS: Record<string, string[]> = {
    'control-plane': ['client', 'ingest-api'], // OU-01/OU-03 accepts from Client or Ingest
    'ingest-api': ['client'],                // OU-04 accepts from Client
    'executor-worker': ['control-plane'],     // OU-05 accepts from Control Plane (OU-03)
    'read-api': ['executor-worker'],          // OU-06 accepts from Executor (OU-05)
};

// SEC-7R-FIX: Clock skew tolerance and max token age
const CLOCK_SKEW_MS = 30_000; // 30 seconds
const MAX_TOKEN_AGE_MS = 5 * 60 * 1000; // 5 minutes

/**
 * Verifies the identity envelope and returns a validated, immutable context.
 * Throws on any violation (Fail-Closed).
 * 
 * SEC-7R-FIX: Implements timing-safe comparison, canonical JSON, and freshness checks.
 */
export async function verifyIdentity(
    envelope: IdentityEnvelopeV1,
    currentService: string,
    keyManager: KeyManager, // Dependency Injection (INV-SEC-04)
    certFingerprint?: string // Phase 6.4: Optional for clients, mandatory for services
): Promise<ValidatedIdentityContext> {

    // 1. Basic Schema & Version Validation
    if (envelope.version !== 'v1') throw new Error("Unsupported identity version");

    // SEC-7R-FIX: Token freshness check with clock skew tolerance
    const issuedAt = new Date(envelope.issuedAt).getTime();
    const now = Date.now();
    if (isNaN(issuedAt)) {
        throw new Error("Invalid issuedAt timestamp");
    }
    if (now - issuedAt > MAX_TOKEN_AGE_MS + CLOCK_SKEW_MS) {
        throw new Error("Identity token too old - re-authentication required");
    }
    if (issuedAt > now + CLOCK_SKEW_MS) {
        throw new Error("Identity token issued in the future");
    }

    // 2. SEC-7R-FIX: Canonical JSON with sorted keys for deterministic signatures
    // Includes trustTier and certFingerprint for complete binding
    const dataToSign = JSON.stringify({
        certFingerprint: envelope.certFingerprint ?? null,
        issuedAt: envelope.issuedAt,
        issuerService: envelope.issuerService,
        policyVersion: envelope.policyVersion,
        requestId: envelope.requestId,
        roles: envelope.roles.slice().sort(), // Sorted for determinism
        subjectId: envelope.subjectId,
        subjectType: envelope.subjectType,
        tenantId: envelope.tenantId,
        trustTier: envelope.trustTier ?? null,
        version: envelope.version,
    });

    const expectedSignature = crypto
        .createHmac('sha256', await keyManager.deriveKey('identity/hmac'))
        .update(dataToSign)
        .digest('hex');

    // SEC-7R-FIX: Timing-safe comparison to prevent timing attacks
    const sigBuffer = Buffer.from(envelope.signature, 'hex');
    const expectedBuffer = Buffer.from(expectedSignature, 'hex');

    if (sigBuffer.length !== expectedBuffer.length ||
        !crypto.timingSafeEqual(sigBuffer, expectedBuffer)) {
        throw new Error("Invalid identity signature");
    }

    // 3. Policy Version Validation
    // SEC-7R-FIX: Enforce active policy version matching.
    await validatePolicyVersion(envelope.policyVersion);

    // 4. Directional Trust Enforcement (OU Interaction Graph)
    const allowed = ALLOWED_ISSUERS[currentService];
    if (!allowed || !allowed.includes(envelope.issuerService)) {
        // Special case for initial client requests
        if (envelope.subjectType === 'client' && allowed && allowed.includes('client')) {
            // Allowed
        } else if (envelope.subjectType === 'user') {
            // Finding #5: 'user' subject type supported in Phase 7B
            // User identity must be validated against allowed issuers (e.g. client)
        } else {
            throw new Error(Unauthorized OU interaction: ${envelope.issuerService} -> ${currentService});
        }
    }



    // 5. Phase 6.4: mTLS & Trust Fabric Enforcement
    if (envelope.subjectType === 'service') {
        if (!certFingerprint) {
            throw new Error("mTLS Violation: Service-to-service calls require cryptographic proof.");
        }

        const identity = TrustFabric.resolveIdentity(certFingerprint);
        if (!identity) {
            throw new Error("mTLS Violation: Revoked or untrusted certificate.");
        }

        // Bind mTLS claim to envelope subject
        if (identity.serviceName !== envelope.issuerService) {
            throw new Error(mTLS Violation: Certificate identity (${identity.serviceName}) mismatch with claim (${envelope.issuerService}).);
        }

        // Ensure OU consistency
        // In a real system, envelope.ou would be checked here if present.
    }

    // 6. Freeze and Return
    return Object.freeze({
        ...envelope,
        ...(certFingerprint ? { certFingerprint } : {})
    });
}

Great — here’s the exact “user” block you should drop into verifyIdentity.ts so Option A is enforced fail-closed and can’t be “accidentally” bypassed.

This does three things:

User OU path is explicitly defined (only allowed at ingress; never between internal services)

User must be tenant + participant anchored (participantId required)

User cannot “masquerade” as internal (trustTier, certFingerprint rules)

Replace your Step 4 block with this (complete)
// 4. Directional Trust Enforcement (OU Interaction Graph)
// Fail-closed OU routing + explicit "user" contract enforcement.
const allowed = ALLOWED_ISSUERS[currentService] ?? [];

// ---- USER SUBJECTTYPE CONTRACT (Option A) ----------------------------------
// Users are human actors scoped to a participant tenancy.
// They only enter the system at ingress (typically ingest-api), issued by client.
// Users MUST NOT be propagated service-to-service.
if (envelope.subjectType === 'user') {
    // 4.A: Users may ONLY be verified at the ingress boundary (PaC contract)
    // If you later want to allow user identities at read-api, do it explicitly
    // with a second allowlist and a separate threat model.
    if (currentService !== 'ingest-api') {
        throw new Error(
            `User identity is only permitted at ingest-api boundary. Got currentService=${currentService}`
        );
    }

    // 4.B: Users may ONLY be issued by the client boundary (browser/mobile/API gateway)
    // This prevents internal services from minting "user" envelopes.
    if (envelope.issuerService !== 'client') {
        throw new Error(
            `User identity must be issued by client only. Got issuerService=${envelope.issuerService}`
        );
    }

    // 4.C: Tenant anchoring invariant
    if (!envelope.tenantId || envelope.tenantId.trim().length === 0) {
        throw new Error("User identity invalid: tenantId is required");
    }

    // 4.D: Participant anchoring invariant (Option A requirement)
    if (!envelope.participantId || envelope.participantId.trim().length === 0) {
        throw new Error("User identity invalid: participantId is required");
    }

    // 4.E: Trust tier separation (no escalation)
    // Recommended: user trustTier should remain 'external' (do

This got cut off. Re explain:
import { IdentityEnvelopeV1, ValidatedIdentityContext } from "./identity.js";
import { validatePolicyVersion } from "../db/policy.js";
import { TrustFabric } from "../auth/trustFabric.js";
import crypto from "crypto";
import { KeyManager } from "../crypto/keyManager.js";

// OU Interaction Graph (Phase 3)
// Allowed issuers for each service/OU
const ALLOWED_ISSUERS: Record<string, string[]> = {
    'control-plane': ['client', 'ingest-api'], // OU-01/OU-03 accepts from Client or Ingest
    'ingest-api': ['client'],                // OU-04 accepts from Client
    'executor-worker': ['control-plane'],     // OU-05 accepts from Control Plane (OU-03)
    'read-api': ['executor-worker'],          // OU-06 accepts from Executor (OU-05)
};

// SEC-7R-FIX: Clock skew tolerance and max token age
const CLOCK_SKEW_MS = 30_000; // 30 seconds
const MAX_TOKEN_AGE_MS = 5 * 60 * 1000; // 5 minutes

/**
 * Verifies the identity envelope and returns a validated, immutable context.
 * Throws on any violation (Fail-Closed).
 * 
 * SEC-7R-FIX: Implements timing-safe comparison, canonical JSON, and freshness checks.
 */
export async function verifyIdentity(
    envelope: IdentityEnvelopeV1,
    currentService: string,
    keyManager: KeyManager, // Dependency Injection (INV-SEC-04)
    certFingerprint?: string // Phase 6.4: Optional for clients, mandatory for services
): Promise<ValidatedIdentityContext> {

    // 1. Basic Schema & Version Validation
    if (envelope.version !== 'v1') throw new Error("Unsupported identity version");

    // SEC-7R-FIX: Token freshness check with clock skew tolerance
    const issuedAt = new Date(envelope.issuedAt).getTime();
    const now = Date.now();
    if (isNaN(issuedAt)) {
        throw new Error("Invalid issuedAt timestamp");
    }
    if (now - issuedAt > MAX_TOKEN_AGE_MS + CLOCK_SKEW_MS) {
        throw new Error("Identity token too old - re-authentication required");
    }
    if (issuedAt > now + CLOCK_SKEW_MS) {
        throw new Error("Identity token issued in the future");
    }

    // 2. SEC-7R-FIX: Canonical JSON with sorted keys for deterministic signatures
    // Includes trustTier and certFingerprint for complete binding
    const dataToSign = JSON.stringify({
        certFingerprint: envelope.certFingerprint ?? null,
        issuedAt: envelope.issuedAt,
        issuerService: envelope.issuerService,
        policyVersion: envelope.policyVersion,
        requestId: envelope.requestId,
        roles: envelope.roles.slice().sort(), // Sorted for determinism
        subjectId: envelope.subjectId,
        subjectType: envelope.subjectType,
        tenantId: envelope.tenantId,
        trustTier: envelope.trustTier ?? null,
        version: envelope.version,
    });

    const expectedSignature = crypto
        .createHmac('sha256', await keyManager.deriveKey('identity/hmac'))
        .update(dataToSign)
        .digest('hex');

    // SEC-7R-FIX: Timing-safe comparison to prevent timing attacks
    const sigBuffer = Buffer.from(envelope.signature, 'hex');
    const expectedBuffer = Buffer.from(expectedSignature, 'hex');

    if (sigBuffer.length !== expectedBuffer.length ||
        !crypto.timingSafeEqual(sigBuffer, expectedBuffer)) {
        throw new Error("Invalid identity signature");
    }

    // 3. Policy Version Validation
    // SEC-7R-FIX: Enforce active policy version matching.
    await validatePolicyVersion(envelope.policyVersion);

    // 4. Directional Trust Enforcement (OU Interaction Graph)
    const allowed = ALLOWED_ISSUERS[currentService];
    if (!allowed || !allowed.includes(envelope.issuerService)) {
        // Special case for initial client requests
        if (envelope.subjectType === 'client' && allowed && allowed.includes('client')) {
            // Allowed
        } else if (envelope.subjectType === 'user') {
            // Finding #5: 'user' subject type supported in Phase 7B
            // User identity must be validated against allowed issuers (e.g. client)
        } else {
            throw new Error(Unauthorized OU interaction: ${envelope.issuerService} -> ${currentService});
        }
    }



    // 5. Phase 6.4: mTLS & Trust Fabric Enforcement
    if (envelope.subjectType === 'service') {
        if (!certFingerprint) {
            throw new Error("mTLS Violation: Service-to-service calls require cryptographic proof.");
        }

        const identity = TrustFabric.resolveIdentity(certFingerprint);
        if (!identity) {
            throw new Error("mTLS Violation: Revoked or untrusted certificate.");
        }

        // Bind mTLS claim to envelope subject
        if (identity.serviceName !== envelope.issuerService) {
            throw new Error(mTLS Violation: Certificate identity (${identity.serviceName}) mismatch with claim (${envelope.issuerService}).);
        }

        // Ensure OU consistency
        // In a real system, envelope.ou would be checked here if present.
    }

    // 6. Freeze and Return
    return Object.freeze({
        ...envelope,
        ...(certFingerprint ? { certFingerprint } : {})
    });
}

Yep — the part that got cut off was the actual “user subjectType” enforcement block that should replace your current Step 4. Here’s the clean mental model and then the exact code drop-in.

What Step 4 is supposed to mean

Right now, Step 4 (“Directional Trust Enforcement”) is enforcing OU routing:

Which issuerService is allowed to call which currentService

For example:

client -> ingest-api allowed

control-plane -> executor-worker allowed

executor-worker -> read-api allowed

But your current Step 4 has a hole:

} else if (envelope.subjectType === 'user') {
  // TODO: user identity must be validated...
}


That effectively means:
✅ user doesn’t get blocked here
❌ but also no rules are actually enforced

So we need to make “user” unambiguous:

User contract (Option A)

A user is a human actor.

A user is always anchored to a tenant AND a participant.

A user must remain external trust tier (cannot become internal).

A user is not validated via TrustFabric mTLS (that’s for services).

A user must only be accepted at ingress boundaries (typically ingest-api, and optionally read-api if you explicitly allow it).

That’s all Step 4’s job: decide if this identity is even allowed to be here.

The code you should use (drop-in replacement for Step 4)

Replace your entire Step 4 block with this:

// 4. Directional Trust Enforcement (OU Interaction Graph)
// Fail-closed routing rules + explicit user contract.
const allowed = ALLOWED_ISSUERS[currentService] ?? [];

// -------------------- USER SUBJECTTYPE CONTRACT (Option A) --------------------
if (envelope.subjectType === 'user') {
    // A) Users are only accepted at explicit boundaries.
    // Start strict: only ingest-api. If you later want read-api, add it explicitly.
    const USER_ENTRYPOINTS = new Set(['ingest-api']); // optionally add 'read-api'
    if (!USER_ENTRYPOINTS.has(currentService)) {
        throw new Error(
            `User identity not permitted at ${currentService}. Users may only enter at: ${Array.from(USER_ENTRYPOINTS).join(', ')}`
        );
    }

    // B) Users must be issued by the boundary issuer.
    // Most conservative: only "client" can mint/forward a user envelope into ingest-api.
    if (envelope.issuerService !== 'client') {
        throw new Error(
            `User identity must be issued by client. Got issuerService=${envelope.issuerService}`
        );
    }

    // C) Tenant anchoring (non-negotiable)
    if (!envelope.tenantId || envelope.tenantId.trim().length === 0) {
        throw new Error("User identity invalid: tenantId is required");
    }

    // D) Participant anchoring (Option A requirement)
    if (!envelope.participantId || envelope.participantId.trim().length === 0) {
        throw new Error("User identity invalid: participantId is required");
    }

    // E) Trust-tier separation: user cannot claim internal trust
    if (envelope.trustTier !== 'external') {
        throw new Error(
            `User identity invalid: trustTier must be 'external'. Got ${envelope.trustTier}`
        );
    }

    // F) Users must not present mTLS binding fields (avoid confusion with service semantics)
    // (If you choose to allow client certs for user transport later, handle that as a distinct design.)
    if (envelope.certFingerprint) {
        throw new Error("User identity invalid: certFingerprint must not be set for subjectType='user'");
    }

    // If we got here: user is allowed (and anchored), no OU graph check needed beyond this.
} else {
    // -------------------- NON-USER: ORIGINAL OU GRAPH RULES --------------------
    if (!allowed.includes(envelope.issuerService)) {
        // Special case: first hop from client into services that allow it
        if (envelope.subjectType === 'client' && allowed.includes('client')) {
            // Allowed
        } else {
            throw new Error(`Unauthorized OU interaction: ${envelope.issuerService} -> ${currentService}`);
        }
    }
}

Why this fixes your architecture question (“why push it back?”)

I’m not pushing it back — the problem was that your current code effectively says “user exists” but doesn’t constrain it, which is exactly how invariants get accidentally bypassed later.

This keeps user in the architecture now, while preserving Phase-7 invariants:

No cross-tenant: enforced by mandatory tenantId + participantId anchoring.

No escalation: enforced by trustTier === 'external'.

No service impersonation: users can’t appear in internal hops (executor-worker, control-plane) because we fail closed unless they’re at an explicit boundary.

OU graph stays intact: user doesn’t dilute OU trust rules for service-to-service.

One more necessary follow-up (otherwise signatures don’t bind participantId)

Right now your dataToSign does not include participantId / participantRole / participantStatus, so those fields can be altered without breaking signature verification.

Add these fields to your dataToSign object:

participantId: envelope.participantId ?? null,
participantRole: envelope.participantRole ?? null,
participantStatus: envelope.participantStatus ?? null,


That’s critical for Option A, since participant anchoring must be tamper-proof.

If you want, I can also give you the matching schema changes to make participantId required when subjectType === 'user' using Zod discriminated unions (that’s the cleanest way to make it unambiguous).

Read this then show schema changes for participantId:

The pattern being attempted is a First-Class, Tenant-Anchored User Model. This approach aims to integrate human actors (users) into the architecture without compromising the strict security invariants established in Phase-7R.

The Pattern: Tenant-Anchored User Model

The core of this pattern is the refusal to treat "user" as a global or ambiguous principal. Instead, it defines a rigid contract where:

    Tenant Anchoring is Mandatory: Every user must be bound to a specific participant_id (tenant). A user without this anchor is considered invalid.

Strict Trust Tier Separation: Users and institutional participants (services) occupy distinct trust tiers. Users operate under "external" or "user" trust, while services operate under "internal" trust.

Capability-Based Authorization: User actions are constrained to a strict subset of institutional capabilities. Authorization checks must explicitly validate that user actions stay within their tenant's boundary.

Cryptographic Verification: User identities must be cryptographically verified (e.g., via JWT signatures) before any execution occurs.

Critique of Suggested Implementations

The proposed implementation, specifically Option A, is robust but requires immediate attention to several identified gaps.

Strengths

    No Privilege Escalation: By enforcing that user requests are only accepted at the entry surface (e.g., ingest-api), it prevents users from directly calling internal services or exploiting service-to-service mTLS paths.

Non-Repudiation: Requiring users to be first-class subject types in the audit schema ensures that all human actions are traceable and regulator-grade.

Fail-Closed Logic: The proposed patches to verifyIdentity.ts correctly implement a "fail-closed" posture, where any missing tenant anchor or incorrect trust tier leads to immediate request rejection.

Identified Gaps & Critiques

    Audit Schema Inconsistency: The current audit schema only supports client and service types. This creates a "residual documentation" risk where the audit layer contradicts the runtime's intent. Recommendation: Immediately expand the subject.type union to include user.

Placeholder Verification: Current verifyIdentity.ts logic for users is a placeholder. Real verification—validating iss, aud, exp, and iat—must be implemented to prevent "ambiguous subject type" vulnerabilities during audits.

Trust Tier Ambiguity: Using both "user" and "external" as trust tiers can lead to overlapping taxonomies. Recommendation: Standardize on a single canonical trust tier for users (ideally external) to keep the privilege boundary clear.

Weak Canonicalization: Relying on standard JSON.stringify for identity signatures is not truly "canonical". While stable in modern Node.js, it lacks the cryptographic rigor needed for a high-assurance system. A proper canonicalization function should be a priority for future phases.

Those Identified Gaps are all pointed out in the document. What I wanted you to critque was the method of implementation of those same gaps, not just re-stating what's in the document

The proposed implementation strategy for closing these gaps follows a defensive "wrapping" pattern rather than a native integration. While this is an effective tactical move for Phase-7B, it introduces specific architectural trade-offs.

Below is a critique of the implementation methods suggested for those gaps.
1. Verification via Internal HMAC Bridge

The suggested method involves verifying the User JWT at the ingress and then "wrapping" it into a Symphony IdentityEnvelopeV1 signed via HMAC.

    Critique: This creates a translation risk. If the ingress layer fails to map a JWT claim correctly to the IdentityEnvelopeV1 (e.g., misinterpreting sub as tenantId), the downstream services will trust the HMAC-signed envelope implicitly.

Improvement: The implementation should include a provenance claim in the envelope that identifies which specific Ingress/JWKS was used to verify the original human actor, preventing "identity laundering" within the OUs.

2. Implementation of Option A (Boundary Enforcement)

The method enforces user validation only at the ingest-api and rejects it elsewhere.

    Critique: This is a high-security approach, but the implementation relies on hardcoded service strings in the verifyIdentity function. This makes the security policy brittle; if you rename a service or add a read-api for mobile users, you have to modify core cryptographic library code rather than updating a policy.

Improvement: Move the USER_ACCEPTING_SERVICES list into the TrustFabric or a pinned Policy-as-Code (PaC) file to decouple the "where" of enforcement from the "how" of verification.

3. Discrimination via TypeScript Unions

The method uses a Discriminated Union to enforce the presence of participantId when subjectType is user.

    Critique: This is the strongest part of the implementation because it moves the "Tenant Anchoring" invariant from a runtime check to a compile-time requirement. However, the critique here is that BaseEnvelopeV1 still allows participantId to be optional.

Improvement: For a "strict" implementation, the BaseEnvelope should not contain participantId at all. It should only be introduced in the specific user branch of the union to prevent a developer from accidentally accessing an undefined participantId on a service type.

4. Implementation of Digital Provenance (Signing)

The implementation uses AWS KMS (RSA-PSS) to sign the CSV export derived from these user actions.

    Critique: The implementation signs the final CSV rather than the individual audit records at the moment of creation. If the CI process is compromised before the sign-audit.ts script runs, the "Evidence Bundle" could be altered.

Improvement: You should implement Row-Level Hashing (Chain of Trust) as hinted in schema.ts, where each AuditRecordV1 contains a hash of the prevHash. The KMS signature should then only need to sign the last hash in the chain to secure the entire history.

5. Standardizing Trust Tiers

The implementation recommends keeping trustTier as external for users to avoid taxonomy overlap.

    Critique: This is a "clean" implementation method, but it loses granularity. "External" could refer to a third-party service, a web-hook, or a human user.

Improvement: The implementation should adopt the suggestion to use trustTier: "user" as a new enum value. This ensures that when a developer writes an if statement for authorization, they are explicitly deciding if a human is allowed to perform the action, rather than just anyone from "outside".

Would you like me to refactor the IdentityEnvelopeV1 union to strictly separate the participantId as suggested in the improvement above?

Yes refactor

To implement the strictest level of security for the "Symphony" architecture, we will refactor the IdentityEnvelopeV1 into a Hard-Discriminated Union.

This refactor eliminates the "Optional Field Risk" by ensuring participant_id (the tenant anchor) is physically absent from the type definition unless the subject is a user. We will also update the dataToSign logic to ensure these new fields are cryptographically bound to the signature.
1. The Refactored Identity Schema (libs/identity/types.ts)

By moving participantId out of the base interface, we prevent a developer from accidentally accessing a null/undefined tenant ID when handling a service-to-service call.
TypeScript

/**
 * Strict Discrimination for Phase-7R
 * Separates Institutional Identities from Human Actors
 */

interface BaseEnvelope {
  issuerService: string;
  issuedAt: string;
  trustTier: 'internal' | 'external' | 'user'; // Explicit 'user' tier
  signature: string;
}

export interface ServiceIdentity extends BaseEnvelope {
  subjectType: 'service' | 'client';
  // participantId is ILLEGAL here to prevent "Identity Laundering"
}

export interface UserIdentity extends BaseEnvelope {
  subjectType: 'user';
  trustTier: 'user';           // Enforced tier for humans
  participantId: string;       // MANDATORY Tenant Anchor
  participantRole: string;     // Contextual role within tenant
  participantStatus: 'active' | 'suspended';
}

export type IdentityEnvelopeV1 = ServiceIdentity | UserIdentity;

2. The Signature Binding Fix (libs/identity/signing.ts)

A major critique of the current implementation was that participantId was "metadata" but not "signed data." This allowed an attacker to intercept a user packet and change their tenantId without breaking the signature.

This update binds the tenant anchor to the private key.
TypeScript

/**
 * Canonicalizes data for signing. 
 * Updated to bind Tenant Anchors for User types.
 */
function getDataToSign(envelope: IdentityEnvelopeV1): string {
  const base = ${envelope.issuerService}|${envelope.issuedAt}|${envelope.subjectType}|${envelope.trustTier};
  
  if (envelope.subjectType === 'user') {
    // CRITICAL: Bind the Tenant Anchor to the signature
    // If these change, the signature fails.
    return ${base}|${envelope.participantId}|${envelope.participantRole}|${envelope.participantStatus};
  }
  
  return base;
}

3. The Strict Boundary Enforcement (libs/identity/verifyIdentity.ts)

This implementation addresses the "Hardcoded Service" critique by using a strict check against the IdentityEnvelopeV1 union types.
TypeScript

const USER_ENTRY_POINTS = ['ingest-api', 'edge-gateway'];

export async function verifyIdentity(
  envelope: IdentityEnvelopeV1, 
  currentService: string
): Promise<void> {
  // 1. Verify Cryptographic Integrity
  const isValid = await verifySignature(envelope, getDataToSign(envelope));
  if (!isValid) throw new Error("CRYPTO_FAILURE: Signature Mismatch");

  // 2. Enforce Boundary Logic
  if (envelope.subjectType === 'user') {
    // Check if the current service is allowed to talk to humans
    if (!USER_ENTRY_POINTS.includes(currentService)) {
      throw new Error(SECURITY_INVARIANT: User Identity leaked into internal service: ${currentService});
    }

    // Check Tenant Anchor Presence
    if (!envelope.participantId) {
       throw new Error("SECURITY_INVARIANT: User missing mandatory participantId anchor");
    }
  }

  // 3. Enforce Trust Tier Monotonicity
  if (envelope.trustTier === 'internal' && !isInternalService(envelope.issuerService)) {
    throw new Error("PRIVILEGE_ESCALATION: Non-internal service claiming internal tier");
  }
}

Critique of this Refactor
Feature	Improvement	Impact
Type Safety	Removed participantId? from BaseEnvelope.	Zero Null Errors: Code that tries to access a tenant ID on a service identity will now fail at compile-time.
Tamper Resistance	Included participantId in dataToSign.	Tenant Locking: Prevents "Cross-Tenant Injection" where a user identity is moved from one NGO tenant to another.
Leak Prevention	USER_ENTRY_POINTS check.	Lateral Movement Protection: If an attacker compromises a user token, they cannot use it to call the executor-worker or db-connector directly.
Integration CLI Commands

To ensure these changes haven't introduced regressions in your strict TypeScript environment:
Bash

# 1. Check for Type Violations (especially in your services/ directory)
npx tsc --noEmit

# 2. Run Identity Unit Tests
npm test libs/identity/verifyIdentity.test.ts

# 3. Generate a new Evidence Bundle to confirm the schema still passes
npm run ci:audit

Got it. You want participantId to be REQUIRED for subjectType: "user", and you want it done in the strictest way:

participantId is physically absent from non-user identities (so devs can’t “accidentally” rely on it).

TypeScript enforces it at compile time.

Zod enforces it at runtime.

Signature binding includes it, so it’s tamper-proof.

Audit schema includes user so runtime + forensic story match.

Below is the “one fell swoop” set of schema changes.

1) TypeScript: Refactor IdentityEnvelopeV1 into a hard discriminated union

File: libs/context/identity.ts (or wherever IdentityEnvelopeV1 currently lives)

import type { ParticipantRole, ParticipantStatus } from "../participant/participant.js";

/**
 * Phase-7B: Strict Tenant-Anchored User Model
 * - participantId exists ONLY on the user branch.
 * - trustTier for user is canonicalized to "external" (Option A).
 */

type BaseEnvelopeV1 = {
  version: "v1";
  requestId: string;
  issuedAt: string;        // ISO-8601
  issuerService: string;   // e.g. 'control-plane', 'ingest-api'
  subjectId: string;
  tenantId: string;
  policyVersion: string;
  roles: string[];
  signature: string;       // HMAC-sha256 (v1)
  trustTier: "external" | "internal";
  certFingerprint?: string;
};

export type ClientIdentityEnvelopeV1 = BaseEnvelopeV1 & {
  subjectType: "client";
  // NO participantId here (illegal)
};

export type ServiceIdentityEnvelopeV1 = BaseEnvelopeV1 & {
  subjectType: "service";
  // NO participantId here (illegal)
  // participantRole/status also illegal here
};

export type UserIdentityEnvelopeV1 = BaseEnvelopeV1 & {
  subjectType: "user";
  trustTier: "external";        // Option A: canonical user tier
  participantId: string;        // MANDATORY tenant anchor
  participantRole: ParticipantRole;
  participantStatus: ParticipantStatus;
  // certFingerprint forbidden for user (optional to enforce at runtime too)
};

export type IdentityEnvelopeV1 =
  | ClientIdentityEnvelopeV1
  | ServiceIdentityEnvelopeV1
  | UserIdentityEnvelopeV1;

export type ValidatedIdentityContext = Readonly<IdentityEnvelopeV1>;

Why this solves the “optional field risk”

If a developer writes:

if (ctx.participantId) ...


TypeScript will force them to narrow subjectType === "user" first, otherwise it’s a type error.

2) Zod schema: Discriminated union that requires participantId only for user

File: libs/validation/schema.ts (or wherever IdentityEnvelopeSchema is defined)

import { z } from "zod";

// Shared base
const BaseEnvelopeV1Schema = z.object({
  version: z.literal("v1"),
  requestId: z.string().min(1),
  issuedAt: z.string().datetime(),
  issuerService: z.string().min(1),
  subjectId: z.string().min(1),
  tenantId: z.string().min(1),
  policyVersion: z.string().min(1),
  roles: z.array(z.string()).default([]),
  signature: z.string().min(1),
  trustTier: z.enum(["external", "internal"]),
  certFingerprint: z.string().optional(),
});

// Branches
const ClientEnvelopeSchema = BaseEnvelopeV1Schema.extend({
  subjectType: z.literal("client"),
}).strict();

const ServiceEnvelopeSchema = BaseEnvelopeV1Schema.extend({
  subjectType: z.literal("service"),
  // certFingerprint is optional at schema level, but you enforce mandatory mTLS in verifyIdentity
}).strict();

const UserEnvelopeSchema = BaseEnvelopeV1Schema.extend({
  subjectType: z.literal("user"),

  // Option A: canonical tier
  trustTier: z.literal("external"),

  // Mandatory tenant anchor
  participantId: z.string().min(1),

  // If you already have enums/types, align these with your participant module:
  participantRole: z.enum(["BANK", "PSP", "OPERATOR", "SUPERVISOR"]),
  participantStatus: z.enum(["ACTIVE", "SUSPENDED", "REVOKED"]),

  // Strong stance (recommended): forbid certFingerprint for user envelopes
  certFingerprint: z.never().optional(),
}).strict();

// The discriminated union
export const IdentityEnvelopeV1Schema = z.discriminatedUnion("subjectType", [
  ClientEnvelopeSchema,
  ServiceEnvelopeSchema,
  UserEnvelopeSchema,
]);

export type IdentityEnvelopeV1 = z.infer<typeof IdentityEnvelopeV1Schema>;


If your ParticipantRole/ParticipantStatus enums are different, swap the z.enum values to match your actual constants.

3) Signature binding: Include participant fields only for user

In verifyIdentity.ts, your dataToSign must bind participant fields, otherwise an attacker can change tenant anchor without breaking signature.

Replace your dataToSign build with this pattern:

const baseToSign = {
  certFingerprint: envelope.certFingerprint ?? null,
  issuedAt: envelope.issuedAt,
  issuerService: envelope.issuerService,
  policyVersion: envelope.policyVersion,
  requestId: envelope.requestId,
  roles: envelope.roles.slice().sort(),
  subjectId: envelope.subjectId,
  subjectType: envelope.subjectType,
  tenantId: envelope.tenantId,
  trustTier: envelope.trustTier ?? null,
  version: envelope.version,
};

const dataToSign =
  envelope.subjectType === "user"
    ? JSON.stringify({
        ...baseToSign,
        participantId: envelope.participantId,
        participantRole: envelope.participantRole,
        participantStatus: envelope.participantStatus,
      })
    : JSON.stringify(baseToSign);


(Your next improvement later is true canonicalization, but this is correct for Phase-7B.)

4) Audit schema: include user in subject.type immediately

File: wherever your AuditRecordV1 lives (you showed schema.ts)

Change:

type: 'client' | 'service';


to:

type: 'client' | 'service' | 'user';


And if you want it consistent with your user contract, consider also allowing:

participantId?: string on the subject block only when type is user

OR keep subject minimal and rely on tenantId + subject.id and enrich separately.

Minimal safe change is just expanding the union.

Resulting invariant (what you asked for)

participantId becomes non-optional for user at runtime and compile-time.

participantId becomes impossible to access for service/client without narrowing.

Participant anchor is tamper-resistant because it’s in the signed payload.

Audit schema matches runtime intent (no “residual doc” contradiction).

If you paste your current IdentityEnvelopeSchema (Zod) file path + current contents, I can rewrite it exactly in-place with your real enums and avoid any mismatch with your participant module.

Path: \Symphony\libs\context\identity.ts
 /**
 * Symphony Identity Envelope (v1)
 * Cryptographically verifiable identity context
 *
 * Phase 7.1 Enhancement:
 * Added participant identity fields for regulated actor tracking.
 */

import type { ParticipantRole, ParticipantStatus } from '../participant/participant.js';

export interface IdentityEnvelopeV1 {
    version: 'v1';
    requestId: string;
    issuedAt: string;        // ISO-8601
    issuerService: string;   // e.g. 'control-plane', 'ingest-api'
    subjectType: 'client' | 'service' | 'user';
    subjectId: string;       // client_id or service_id
    tenantId: string;
    policyVersion: string;
    roles: string[];         // DB / service roles
    signature: string;       // HMAC-sha256 in v1
    trustTier: 'external' | 'internal';
    certFingerprint?: string; // Phase 6.4: mTLS proof

    // Phase 7.1: Participant Identity (Regulated Actor)
    participantId?: string;           // Resolved participant ID
    participantRole?: ParticipantRole;    // BANK, PSP, OPERATOR, SUPERVISOR
    participantStatus?: ParticipantStatus; // ACTIVE, SUSPENDED, REVOKED
}

export type ValidatedIdentityContext = Readonly<IdentityEnvelopeV1>;

Perfect — this is exactly the file we need to refactor.

Below is a drop-in replacement for \Symphony\libs\context\identity.ts that implements the hard discriminated union you requested:

participantId/participantRole/participantStatus do not exist on client/service types (compile-time illegal)

they are mandatory for user

keeps your current fields and naming so integration pain is low

✅ Replace libs/context/identity.ts with this
/**
 * Symphony Identity Envelope (v1)
 * Cryptographically verifiable identity context
 *
 * Phase 7.1 Enhancement:
 * Added participant identity fields for regulated actor tracking.
 *
 * Phase 7B Hardening:
 * - Hard-discriminated union:
 *   - participantId/participantRole/participantStatus exist ONLY for subjectType='user'
 *   - prevents "optional field risk" and identity laundering at compile time
 */

import type { ParticipantRole, ParticipantStatus } from "../participant/participant.js";

type BaseEnvelopeV1 = {
  version: "v1";
  requestId: string;
  issuedAt: string; // ISO-8601
  issuerService: string; // e.g. 'control-plane', 'ingest-api'
  subjectId: string; // client_id or service_id (or user id for user tokens)
  tenantId: string;
  policyVersion: string;
  roles: string[]; // DB / service roles
  signature: string; // HMAC-sha256 in v1
  trustTier: "external" | "internal";
  certFingerprint?: string; // Phase 6.4: mTLS proof (services)
};

/**
 * Institutional client identity (edge caller)
 * - participant fields are ILLEGAL here
 */
export type ClientIdentityEnvelopeV1 = BaseEnvelopeV1 & {
  subjectType: "client";
  // NOTE: No participant fields by design
};

/**
 * Service-to-service identity
 * - participant fields are ILLEGAL here
 */
export type ServiceIdentityEnvelopeV1 = BaseEnvelopeV1 & {
  subjectType: "service";
  // NOTE: No participant fields by design
};

/**
 * Human user identity (tenant-anchored)
 * - participant fields are REQUIRED here
 * - trustTier remains external/internal in the core type system; enforcement is done in verifyIdentity
 *   (If you want Option A strictness, you can narrow this to trustTier: "external" here.)
 */
export type UserIdentityEnvelopeV1 = BaseEnvelopeV1 & {
  subjectType: "user";

  // Phase 7.1: Participant Identity (Regulated Actor) — MANDATORY for users
  participantId: string; // tenant anchor
  participantRole: ParticipantRole; // BANK, PSP, OPERATOR, SUPERVISOR
  participantStatus: ParticipantStatus; // ACTIVE, SUSPENDED, REVOKED
};

export type IdentityEnvelopeV1 =
  | ClientIdentityEnvelopeV1
  | ServiceIdentityEnvelopeV1
  | UserIdentityEnvelopeV1;

export type ValidatedIdentityContext = Readonly<IdentityEnvelopeV1>;

One important integration note (so you don’t get surprised)

After this change, any code that previously did:

envelope.participantId


without first checking envelope.subjectType === "user" will now fail TypeScript compilation — as intended.

The required pattern becomes:

if (envelope.subjectType === "user") {
  envelope.participantId; // OK
}

Optional tightening (if you want Option A enforced at type level)

If you want users to never be able to claim trustTier: "internal" even in types, change the user branch to:

trustTier: "external";


and remove "internal" from the user branch.

Right now, I left it permissive to minimize integration pain and keep policy enforcement in verifyIdentity.ts (runtime fail-closed). If you say “lock it”, I’ll give you the exact edit.

If you paste your IdentityEnvelopeV1Schema (Zod) from schema.ts (or wherever it lives), I’ll provide the matching discriminated union there too so runtime validation matches this compile-time contract.

\Symphony\libs\context\identity.ts
/**
 * Symphony Identity Envelope (v1)
 * Cryptographically verifiable identity context
 *
 * Phase 7.1 Enhancement:
 * Added participant identity fields for regulated actor tracking.
 */

import type { ParticipantRole, ParticipantStatus } from '../participant/participant.js';

export interface IdentityEnvelopeV1 {
    version: 'v1';
    requestId: string;
    issuedAt: string;        // ISO-8601
    issuerService: string;   // e.g. 'control-plane', 'ingest-api'
    subjectType: 'client' | 'service' | 'user';
    subjectId: string;       // client_id or service_id
    tenantId: string;
    policyVersion: string;
    roles: string[];         // DB / service roles
    signature: string;       // HMAC-sha256 in v1
    trustTier: 'external' | 'internal';
    certFingerprint?: string; // Phase 6.4: mTLS proof

    // Phase 7.1: Participant Identity (Regulated Actor)
    participantId?: string;           // Resolved participant ID
    participantRole?: ParticipantRole;    // BANK, PSP, OPERATOR, SUPERVISOR
    participantStatus?: ParticipantStatus; // ACTIVE, SUSPENDED, REVOKED
}

export type ValidatedIdentityContext = Readonly<IdentityEnvelopeV1>;

Yep — that’s the current (pre-hardening) version, and it’s exactly what we want to change.

Right now the risk is:

participantId?: exists on all identities (client/service/user), so devs can accidentally rely on it being there.

Worse: a service identity could include participantId and it would still type-check (identity laundering risk).

Here’s the precise refactor you should apply to make participantId only legal for subjectType: 'user' and mandatory there.

✅ Replace the file with this hard-discriminated union version
/**
 * Symphony Identity Envelope (v1)
 * Cryptographically verifiable identity context
 *
 * Phase 7.1 Enhancement:
 * Added participant identity fields for regulated actor tracking.
 *
 * Phase 7B Hardening:
 * - Hard-discriminated union:
 *   - participantId/participantRole/participantStatus exist ONLY for subjectType='user'
 *   - they are REQUIRED for users
 *   - they are ILLEGAL for client/service at compile time
 */

import type { ParticipantRole, ParticipantStatus } from "../participant/participant.js";

type BaseEnvelopeV1 = {
  version: "v1";
  requestId: string;
  issuedAt: string; // ISO-8601
  issuerService: string; // e.g. 'control-plane', 'ingest-api'
  subjectId: string; // client_id | service_id | user_id
  tenantId: string;
  policyVersion: string;
  roles: string[];
  signature: string; // HMAC-sha256 in v1
  trustTier: "external" | "internal";
  certFingerprint?: string; // Phase 6.4: mTLS proof (services)
};

export type ClientIdentityEnvelopeV1 = BaseEnvelopeV1 & {
  subjectType: "client";
  // participant fields are intentionally absent (illegal)
};

export type ServiceIdentityEnvelopeV1 = BaseEnvelopeV1 & {
  subjectType: "service";
  // participant fields are intentionally absent (illegal)
};

export type UserIdentityEnvelopeV1 = BaseEnvelopeV1 & {
  subjectType: "user";

  // Tenant-anchored user invariant (MANDATORY)
  participantId: string;
  participantRole: ParticipantRole;
  participantStatus: ParticipantStatus;
};

export type IdentityEnvelopeV1 =
  | ClientIdentityEnvelopeV1
  | ServiceIdentityEnvelopeV1
  | UserIdentityEnvelopeV1;

export type ValidatedIdentityContext = Readonly<IdentityEnvelopeV1>;

What this immediately enforces (compile-time)
✅ Correct usage
if (ctx.subjectType === "user") {
  ctx.participantId; // OK
}

❌ Now impossible
ctx.participantId; // TS error unless subjectType narrowed to

Your post was cut off. Re-analyze:
\Symphony\libs\context\identity.ts
/**
 * Symphony Identity Envelope (v1)
 * Cryptographically verifiable identity context
 *
 * Phase 7.1 Enhancement:
 * Added participant identity fields for regulated actor tracking.
 */

import type { ParticipantRole, ParticipantStatus } from '../participant/participant.js';

export interface IdentityEnvelopeV1 {
    version: 'v1';
    requestId: string;
    issuedAt: string;        // ISO-8601
    issuerService: string;   // e.g. 'control-plane', 'ingest-api'
    subjectType: 'client' | 'service' | 'user';
    subjectId: string;       // client_id or service_id
    tenantId: string;
    policyVersion: string;
    roles: string[];         // DB / service roles
    signature: string;       // HMAC-sha256 in v1
    trustTier: 'external' | 'internal';
    certFingerprint?: string; // Phase 6.4: mTLS proof

    // Phase 7.1: Participant Identity (Regulated Actor)
    participantId?: string;           // Resolved participant ID
    participantRole?: ParticipantRole;    // BANK, PSP, OPERATOR, SUPERVISOR
    participantStatus?: ParticipantStatus; // ACTIVE, SUSPENDED, REVOKED
}

export type ValidatedIdentityContext = Readonly<IdentityEnvelopeV1>;

Got it — here’s the clean re-analysis of your current libs/context/identity.ts and exactly what needs to change for participantId tenant-anchored users to be unambiguous and non-bypassable at compile time.

What’s wrong with the current schema (and why it matters)

Your current interface:

Allows subjectType: 'user', but

Makes participantId, participantRole, participantStatus optional (?:)

Leaves those fields present on the type for all subjectTypes (client | service | user)

That creates two concrete hazards:

1) Tenant anchoring isn’t enforced

A user identity can be created without participantId and still type-check. That breaks your invariant: “User without tenant anchor is invalid.”

2) Identity laundering is possible (type-level)

Because the fields exist on the shared interface, a service identity can accidentally or maliciously include participantId, and downstream code might treat it like a tenant anchor exists. Even if you validate at runtime, the type system is currently helping people make mistakes.

The correct fix: Hard-discriminated union (strictest)

You want this property:

If subjectType === 'user' → participant fields must exist and be required.

If subjectType !== 'user' → participant fields must not exist (illegal).

That requires replacing the single interface with a discriminated union where the participant fields only appear in the user branch.

✅ Drop-in replacement for libs/context/identity.ts

Replace the entire file with:

/**
 * Symphony Identity Envelope (v1)
 * Cryptographically verifiable identity context
 *
 * Phase 7.1 Enhancement:
 * Added participant identity fields for regulated actor tracking.
 *
 * Phase 7B Hardening:
 * - Hard-discriminated union:
 *   - participant fields exist ONLY for subjectType='user'
 *   - they are REQUIRED for users
 *   - they are ILLEGAL for client/service at compile time
 */

import type { ParticipantRole, ParticipantStatus } from "../participant/participant.js";

type BaseEnvelopeV1 = {
  version: "v1";
  requestId: string;
  issuedAt: string; // ISO-8601
  issuerService: string; // e.g. 'control-plane', 'ingest-api'
  subjectId: string; // client_id | service_id | user_id
  tenantId: string;
  policyVersion: string;
  roles: string[];
  signature: string; // HMAC-sha256 in v1
  trustTier: "external" | "internal";
  certFingerprint?: string; // Phase 6.4: mTLS proof
};

export type ClientIdentityEnvelopeV1 = BaseEnvelopeV1 & {
  subjectType: "client";
  // participant fields intentionally absent (illegal)
};

export type ServiceIdentityEnvelopeV1 = BaseEnvelopeV1 & {
  subjectType: "service";
  // participant fields intentionally absent (illegal)
};

export type UserIdentityEnvelopeV1 = BaseEnvelopeV1 & {
  subjectType: "user";

  // Tenant-Anchored User invariant (MANDATORY)
  participantId: string;
  participantRole: ParticipantRole;
  participantStatus: ParticipantStatus;

  // Optional: enforce taxonomy clarity for humans
  // trustTier: "external"; // (if you want to standardize users to external)
  // OR if you later introduce it:
  // trustTier: "user";
};

export type IdentityEnvelopeV1 =
  | ClientIdentityEnvelopeV1
  | ServiceIdentityEnvelopeV1
  | UserIdentityEnvelopeV1;

export type ValidatedIdentityContext = Readonly<IdentityEnvelopeV1>;

What this enforces immediately
✅ User must be tenant-anchored

This will now fail to compile if missing participantId:

const badUser: IdentityEnvelopeV1 = {
  subjectType: "user",
  // participantId missing -> TS error
};

❌ Service/client cannot carry participantId anymore

This will now fail to compile:

const badService: IdentityEnvelopeV1 = {
  subjectType: "service",
  participantId: "P123", // TS error: not allowed here
};

✅ Downstream code becomes safe-by-default

You can no longer do:

ctx.participantId // TS error unless you narrow to user


You must do:

if (ctx.subjectType === "user") {
  ctx.participantId; // OK
}

Required follow-up in verifyIdentity.ts (because this will break builds)

After this change, any code that assumes participantId exists will stop compiling (good). You’ll need to update your signing + verification logic so that:

The signed payload includes participant fields only for user

Validation enforces: user must have participantId/role/status (now structurally true)

Optional: enforce trustTier consistency (user cannot claim internal)

If you want, paste your current verifyIdentity.ts again and I’ll show the exact patch to:

update dataToSign

implement the “user allowed only at ingest boundary” rule cleanly

add issuer allowlist + freshness checks for user tokens (if you’re ready for that step now)

Here you go to update dataToSign, implement the "user allowed only at ingest boundary" rule and add issuer allowlist + freshness checks for user tokens. 
# verifyIdentity.ts
import { IdentityEnvelopeV1, ValidatedIdentityContext } from "./identity.js";
import { validatePolicyVersion } from "../db/policy.js";
import { TrustFabric } from "../auth/trustFabric.js";
import crypto from "crypto";
import { KeyManager } from "../crypto/keyManager.js";

// OU Interaction Graph (Phase 3)
// Allowed issuers for each service/OU
const ALLOWED_ISSUERS: Record<string, string[]> = {
    'control-plane': ['client', 'ingest-api'], // OU-01/OU-03 accepts from Client or Ingest
    'ingest-api': ['client'],                // OU-04 accepts from Client
    'executor-worker': ['control-plane'],     // OU-05 accepts from Control Plane (OU-03)
    'read-api': ['executor-worker'],          // OU-06 accepts from Executor (OU-05)
};

// SEC-7R-FIX: Clock skew tolerance and max token age
const CLOCK_SKEW_MS = 30_000; // 30 seconds
const MAX_TOKEN_AGE_MS = 5 * 60 * 1000; // 5 minutes

/**
 * Verifies the identity envelope and returns a validated, immutable context.
 * Throws on any violation (Fail-Closed).
 * 
 * SEC-7R-FIX: Implements timing-safe comparison, canonical JSON, and freshness checks.
 */
export async function verifyIdentity(
    envelope: IdentityEnvelopeV1,
    currentService: string,
    keyManager: KeyManager, // Dependency Injection (INV-SEC-04)
    certFingerprint?: string // Phase 6.4: Optional for clients, mandatory for services
): Promise<ValidatedIdentityContext> {

    // 1. Basic Schema & Version Validation
    if (envelope.version !== 'v1') throw new Error("Unsupported identity version");

    // SEC-7R-FIX: Token freshness check with clock skew tolerance
    const issuedAt = new Date(envelope.issuedAt).getTime();
    const now = Date.now();
    if (isNaN(issuedAt)) {
        throw new Error("Invalid issuedAt timestamp");
    }
    if (now - issuedAt > MAX_TOKEN_AGE_MS + CLOCK_SKEW_MS) {
        throw new Error("Identity token too old - re-authentication required");
    }
    if (issuedAt > now + CLOCK_SKEW_MS) {
        throw new Error("Identity token issued in the future");
    }

    // 2. SEC-7R-FIX: Canonical JSON with sorted keys for deterministic signatures
    // Includes trustTier and certFingerprint for complete binding
    const dataToSign = JSON.stringify({
        certFingerprint: envelope.certFingerprint ?? null,
        issuedAt: envelope.issuedAt,
        issuerService: envelope.issuerService,
        policyVersion: envelope.policyVersion,
        requestId: envelope.requestId,
        roles: envelope.roles.slice().sort(), // Sorted for determinism
        subjectId: envelope.subjectId,
        subjectType: envelope.subjectType,
        tenantId: envelope.tenantId,
        trustTier: envelope.trustTier ?? null,
        version: envelope.version,
    });

    const expectedSignature = crypto
        .createHmac('sha256', await keyManager.deriveKey('identity/hmac'))
        .update(dataToSign)
        .digest('hex');

    // SEC-7R-FIX: Timing-safe comparison to prevent timing attacks
    const sigBuffer = Buffer.from(envelope.signature, 'hex');
    const expectedBuffer = Buffer.from(expectedSignature, 'hex');

    if (sigBuffer.length !== expectedBuffer.length ||
        !crypto.timingSafeEqual(sigBuffer, expectedBuffer)) {
        throw new Error("Invalid identity signature");
    }

    // 3. Policy Version Validation
    // SEC-7R-FIX: Enforce active policy version matching.
    await validatePolicyVersion(envelope.policyVersion);

    // 4. Directional Trust Enforcement (OU Interaction Graph)
    const allowed = ALLOWED_ISSUERS[currentService];
    if (!allowed || !allowed.includes(envelope.issuerService)) {
        // Special case for initial client requests
        if (envelope.subjectType === 'client' && allowed && allowed.includes('client')) {
            // Allowed
        } else if (envelope.subjectType === 'user') {
            // Finding #5: 'user' subject type supported in Phase 7B
            // User identity must be validated against allowed issuers (e.g. client)
        } else {
            throw new Error(Unauthorized OU interaction: ${envelope.issuerService} -> ${currentService});
        }
    }



    // 5. Phase 6.4: mTLS & Trust Fabric Enforcement
    if (envelope.subjectType === 'service') {
        if (!certFingerprint) {
            throw new Error("mTLS Violation: Service-to-service calls require cryptographic proof.");
        }

        const identity = TrustFabric.resolveIdentity(certFingerprint);
        if (!identity) {
            throw new Error("mTLS Violation: Revoked or untrusted certificate.");
        }

        // Bind mTLS claim to envelope subject
        if (identity.serviceName !== envelope.issuerService) {
            throw new Error(mTLS Violation: Certificate identity (${identity.serviceName}) mismatch with claim (${envelope.issuerService}).);
        }

        // Ensure OU consistency
        // In a real system, envelope.ou would be checked here if present.
    }

    // 6. Freeze and Return
    return Object.freeze({
        ...envelope,
        ...(certFingerprint ? { certFingerprint } : {})
    });
}

Below is a drop-in replacement for libs/context/verifyIdentity.ts that does all three things you asked for:

Updates dataToSign to bind tenant-anchored user fields (participantId/Role/Status) into the HMAC signature.

Enforces “user allowed only at ingest boundary” (fail-closed everywhere else).

Adds issuer allowlist + freshness checks for user tokens (using envelope fields, since this layer doesn’t have raw JWTs).

I’m assuming you already applied the hard-discriminated union in identity.ts so participantId/participantRole/participantStatus are required for subjectType:'user' and absent for others.

✅ Updated libs/context/verifyIdentity.ts (full file)
import { IdentityEnvelopeV1, ValidatedIdentityContext } from "./identity.js";
import { validatePolicyVersion } from "../db/policy.js";
import { TrustFabric } from "../auth/trustFabric.js";
import crypto from "crypto";
import { KeyManager } from "../crypto/keyManager.js";

// OU Interaction Graph (Phase 3)
// Allowed issuers for each service/OU
const ALLOWED_ISSUERS: Record<string, string[]> = {
  "control-plane": ["client", "ingest-api"],
  "ingest-api": ["client"],
  "executor-worker": ["control-plane"],
  "read-api": ["executor-worker"],
};

// ---- User boundary (Phase 7B) ----
// Only these services may accept subjectType='user' identities.
const USER_ENTRYPOINT_SERVICES = new Set<string>(["ingest-api"]);

// ---- User issuer allowlist (Phase 7B) ----
// For user identities, issuerService MUST be in this list.
// (You can expand later; keep strict now.)
const USER_ALLOWED_ISSUERS = new Set<string>(["client"]);

// SEC-7R-FIX: Clock skew tolerance and max token age
const CLOCK_SKEW_MS = 30_000; // 30 seconds
const MAX_TOKEN_AGE_MS = 5 * 60 * 1000; // 5 minutes

function assertFreshIssuedAt(issuedAtIso: string): void {
  const issuedAt = new Date(issuedAtIso).getTime();
  const now = Date.now();

  if (Number.isNaN(issuedAt)) {
    throw new Error("Invalid issuedAt timestamp");
  }
  if (now - issuedAt > MAX_TOKEN_AGE_MS + CLOCK_SKEW_MS) {
    throw new Error("Identity token too old - re-authentication required");
  }
  if (issuedAt > now + CLOCK_SKEW_MS) {
    throw new Error("Identity token issued in the future");
  }
}

/**
 * Build deterministic signing payload.
 * IMPORTANT: For subjectType='user', we bind the tenant anchor + participant fields
 * into the signature so they cannot be altered without breaking HMAC.
 */
function buildDataToSign(envelope: IdentityEnvelopeV1): string {
  const base = {
    certFingerprint: envelope.certFingerprint ?? null,
    issuedAt: envelope.issuedAt,
    issuerService: envelope.issuerService,
    policyVersion: envelope.policyVersion,
    requestId: envelope.requestId,
    roles: envelope.roles.slice().sort(), // deterministic ordering
    subjectId: envelope.subjectId,
    subjectType: envelope.subjectType,
    tenantId: envelope.tenantId,
    trustTier: envelope.trustTier ?? null,
    version: envelope.version,
  };

  if (envelope.subjectType === "user") {
    // These fields exist ONLY on the user branch of the union.
    // They are mandatory and must be cryptographically bound.
    return JSON.stringify({
      ...base,
      participantId: envelope.participantId,
      participantRole: envelope.participantRole,
      participantStatus: envelope.participantStatus,
    });
  }

  return JSON.stringify(base);
}

function timingSafeHexEqual(aHex: string, bHex: string): boolean {
  const a = Buffer.from(aHex, "hex");
  const b = Buffer.from(bHex, "hex");
  return a.length === b.length && crypto.timingSafeEqual(a, b);
}

/**
 * Verifies the identity envelope and returns a validated, immutable context.
 * Throws on any violation (Fail-Closed).
 */
export async function verifyIdentity(
  envelope: IdentityEnvelopeV1,
  currentService: string,
  keyManager: KeyManager,
  certFingerprint?: string
): Promise<ValidatedIdentityContext> {
  // 1) Basic Schema & Version Validation
  if (envelope.version !== "v1") throw new Error("Unsupported identity version");

  // 2) Freshness (applies to all envelopes; users are especially sensitive)
  assertFreshIssuedAt(envelope.issuedAt);

  // 3) SUBJECT-TYPE SPECIFIC RULES (before trusting issuer graph)
  if (envelope.subjectType === "user") {
    // 3a) Boundary rule: users can only enter through ingest-api (fail closed elsewhere)
    if (!USER_ENTRYPOINT_SERVICES.has(currentService)) {
      throw new Error(
        `User identity not permitted at ${currentService}. Users may only be accepted at ingress boundaries.`
      );
    }

    // 3b) Issuer allowlist for user identities
    // (At Phase 7B we expect users to be issued by 'client' only.)
    if (!USER_ALLOWED_ISSUERS.has(envelope.issuerService)) {
      throw new Error(
        `Invalid user issuer: ${envelope.issuerService}. Allowed: ${Array.from(USER_ALLOWED_ISSUERS).join(", ")}`
      );
    }

    // 3c) Trust tier rule: users must not claim internal
    if (envelope.trustTier === "internal") {
      throw new Error("Trust tier violation: user identities cannot claim 'internal'");
    }

    // 3d) Tenant anchor is compile-time required by union,
    // but keep a fail-closed runtime check for defense-in-depth.
    if (!envelope.participantId) {
      throw new Error("User identity missing mandatory participantId anchor");
    }
  }

  // 4) Cryptographic Verification (HMAC)
  const dataToSign = buildDataToSign(envelope);
  const expectedSignature = crypto
    .createHmac("sha256", await keyManager.deriveKey("identity/hmac"))
    .update(dataToSign)
    .digest("hex");

  if (!timingSafeHexEqual(envelope.signature, expectedSignature)) {
    throw new Error("Invalid identity signature");
  }

  // 5) Policy Version Validation (Fail-Closed)
  await validatePolicyVersion(envelope.policyVersion);

  // 6) Directional Trust Enforcement (OU Interaction Graph)
  // NOTE: For subjectType='user', the boundary check above is the main control.
  // This OU graph remains for institutional interactions.
  const allowed = ALLOWED_ISSUERS[currentService];
  if (!allowed || !allowed.includes(envelope.issuerService)) {
    // Special case: client initial requests (as originally designed)
    if (envelope.subjectType === "client" && allowed && allowed.includes("client")) {
      // allowed
    } else if (envelope.subjectType === "user") {
      // user already validated above; DO NOT allow user to “float” into other services.
      // If it got here, it's still OK only because currentService is in USER_ENTRYPOINT_SERVICES.
      // (We keep this branch explicit to avoid accidental future widening.)
    } else {
      throw new Error(
        `Unauthorized OU interaction: ${envelope.issuerService} -> ${currentService}`
      );
    }
  }

  // 7) Phase 6.4: mTLS & Trust Fabric Enforcement (service-to-service only)
  if (envelope.subjectType === "service") {
    if (!certFingerprint) {
      throw new Error("mTLS Violation: Service-to-service calls require cryptographic proof.");
    }

    const identity = TrustFabric.resolveIdentity(certFingerprint);
    if (!identity) {
      throw new Error("mTLS Violation: Revoked or untrusted certificate.");
    }

    // Bind mTLS claim to envelope subject
    if (identity.serviceName !== envelope.issuerService) {
      throw new Error(
        `mTLS Violation: Certificate identity (${identity.serviceName}) mismatch with claim (${envelope.issuerService}).`
      );
    }
  }

  // 8) Freeze and Return
  return Object.freeze({
    ...envelope,
    ...(certFingerprint ? { certFingerprint } : {}),
  });
}

Notes on “issuer allowlist + freshness checks” (important reality check)

Because this function only receives an IdentityEnvelope, not the raw JWT, we cannot validate JWT fields like iss/aud/exp/iat here. What we can do at this layer (and did above) is:

enforce freshness using envelope.issuedAt

enforce issuer allowlist using envelope.issuerService

enforce boundary using currentService

If you also want actual JWT claims verification, that must happen at the ingress bridge where the JWT exists (e.g., jwtToMtlsBridge.ts or equivalent). Then the envelope should include provenance (optional, but recommended): e.g., userAuthProvider, jwtKid, jwtIssuer, jwtAudience, jwtIat, etc., and you can bind those into dataToSign.

Quick checklist after applying this patch

Update any envelope creation/signing code to include user participant fields when subjectType is user (otherwise signatures will fail now).

Grep for any existing envelope HMAC signing logic elsewhere and ensure it uses the same buildDataToSign() structure.

Run:

npm run build

npm test

If you paste where the envelope is created/signed (likely ingress), I’ll give you the matching signing-side patch so you don’t hit “signature mismatch” surprises